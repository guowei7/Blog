---
title: "Byte Aligned"
date: 2021-12-20T14:31:31+08:00
Description: "记录字节对齐的一些规则"
Tags: ["C"]
Categories: ["数据结构"]
DisableComments: false
---

记录字节对齐的一些规则  
<!--more-->
###1. 结构体对齐  
#### 对齐准则  
1. 数据类型自身的对齐值:char型数据自身对齐为1字节，short型数据为2字节，int/float型为4字节，double型为8字节。  
2. 结构体或类的自身对齐值:其成员中自身对齐值最大的那个值。  
3. 指定对齐值:一般会有一个默认对齐值，同时也可以通过#pragma pack(value)来指定对齐值。  
4. 数据成员、结构体和类的有效对齐值:自身对齐值和指定对齐值中较小者，即有效对齐值=min{自身对齐值，当前指定对齐值}  
其中，有效对齐值N是最终用来决定数据存放地质的值。有效对齐N表示“对齐在N上”，即该数据的“存放起始地址%N=0”。而数据结构中的数据变量都是按定义的先后顺序存放。第一个数据变量的起始地质就是数据结构的起始地址。***结构体的成员变量要对齐存放，结构体本身也要根据自身的有效对齐值圆整***(即结构体成员变量占用总长度为结构体有效对齐值的整数倍)  
#### 对齐隐患  
1. 数据类型转换  
``` C
int main(void)
{
	unsigned int i = 0x12345678;

	unsigned char *p = (unsigned char *)&i;
	*p = 0x00;

	unsigned short *p1 = (unsigned short *)(p+1);
	*p1 = 0x0000;
	return 0;
}
```
最后两句代码，从不是short(2)的边界去访问了unsigned short型变量，不符合对齐规定。在X86上，这样的操作只会影响效率；但是有些处理器可能会导致错误。  
2. 处理器间数据通信  
处理器间通过消息进行通信时，需要注意字节对齐以及字节序的问题。  
对于本地使用的数据结构，为提高内存访问效率，采用四字节对齐方式；同时为了减少内存的开销，合理安排结构体成员的位置，减少四字节对齐导致的成员之间的空隙，降低内存开销。  
对于处理器之间的数据结构，需要保证消息长度不会因不同编译平台或处理器而导致消息结构体长度发生变化，使用一字节对齐方式对消息结构进行紧缩；为保证处理器之间的消息数据结构的内存访问效率，采用字节填充的方式自己对消息中成员进行四字节对齐。  
#### 更改对齐方式  
+ 使用伪指令#pragma pack(n):C编译器将按照n个字节对齐  
+ 使用伪指令#pragma pack():取消自定义字节对齐方式  

### 栈内存对齐  
栈对齐方式不受结构体成员对齐选项的影响。总是保持对齐且对齐在4字节边界上。  
