---
title: "C Learning Two"
date: 2020-12-12T19:05:35+08:00
Description: "C primer Plus继续学习"
Tags: ["C"]
Categories: ["编程语言"]
DisableComments: false
---

由于C-Learning.md存在损坏，故重开一篇继续记录  
<!--more-->
### 7. C控制语句：分支和跳转

本章介绍以下内容：  
关键字：if、else、switch、continue、break、case、default、goto  
运算符：&&、||、？ ：   
函数：getchar()、putchar()、ctype.h系列  
如何使用if和if else语句，如何嵌套它们   
在更复杂的测试表达式中用逻辑运算符组合关系表达式  
C的条件运算符  
switch语句  
break、continue和goto语句    
使用C的字符I/O函数：getchar()和puchar()  
ctype.h头文件提供的字符分析函数系列  

#### if语句

下面的程序是读取一系列数据，每个数据都表示每日的最低问题，然后打印统计的总天数和最低温度在0°以下的天数占总天数的百分比。程序中的循环通过scanf()读入温度值。while循环每迭代一次，就递增计数器增加天数，其中的if语句负责判断0°以下的温度并单独统计相应的天数。  
[colddays.c](../../c-example/colddays.c)  
为避免整数除法，该程序示例把计算后的百分比强制转换为float类型。其实，也不必使用强制类型转换，因为在表达式100.0  * cold_dyas / all_days中，将首先对表达式100.0 * cold_days求值，由于C的自动转换类型规则，乘积会被强制转换成浮点数。但是，使用强制类型转换可以明确表达式转换类型的意图，保护程序免受不同版本编译器的影响。if语句被称为分支语句(branching statement)或选择语句(selection statement)，因为它相当于一个交叉点，程序要在两条分支中选择一条执行。if语句的通用形式如下：  

>if(expression)  
>statement  

如果对expression求值为真(非0),则执行statement：否则，跳过statement。与while循环一样，statement可以是一条简单语句或复合语句。if语句的结构和while语句很相似，它们的主要区别是：如果满足条件执行的话，if语句 只能测试和执行一次，而while语句可以测试和执行多次。  
通常，expression是关系表达式，即比较两个量的大小(如，表达式x > y或c == 6)。如果expression为真(即x大于y，或c == 6),则执行statement。否则，忽略statement。概括地说，可以使用任意表达式，表达式的值为0则为假。  
statement部分可以是一条简单语句，如本例所示，或者是一条用花括号括起来的复合语句(或块)  
注意，即使if语句由复合语句构成，整个if语句仍被视为一条语句。  

#### if else语句

简单形式的if语句可以让程序选择执行一条语句，或者跳过这条语句。C还提供了if else形式，可以在两条语句之间作选择。  
注意，if else语句的通用形式是：  

>if(expression)
>statement1
>else
>statement2

如果expression为真(非0),则执行statement1；如果expression为假或0，则执行else后面的statement2。statement1和statement2可以是一条简单语句或复合语句。C并不要求一定要缩进，但这是标准风格。缩进让根据测试条件的求值结果来判断执行哪部分语句一目了然。  
如果要在if和else之间执行多条语句，必须用花括号把这些语句括起来成为一个块。   

+ 介绍getchar()和putchar()  
    getchar()函数不带任何参数，它从输入队列中返回下一个字符。例如，下面的语句读取下一个字符输入，并把该字符的值赋给变量ch：  

    ``` C
    ch = getchar();
    ```

    该语句与下面的语句效果相同：  

    ``` C
    scanf("%c",&ch);
    ```

    putchar函数打印它的参数。例如，下面的语句把之前赋给ch的值作为字符打印出来：  

    ``` C
    putchar(ch);
    ```

    该语句与下面的语句效果相同：  

    ``` C
    printf("%c",ch);
    ```

    由于这些函数只处理字符，所以它们比更通用的scanf()和printf()函数更快、更简洁。而且，注意getchar()和putchar()不需要转换说明，因为它们只处理字符。这两个函数通常定义在stdio.h头文件中(而且，他们通常是预处理宏，而不是真正的函数，第16章会讨论类似函数的宏)。  
    接下来，我们编写一个程序来说明这两个函数是如何工作的。该程序把一行输入重新打印出来，但是每个非空格都被替换成原字符在ASCII序列中的下一个字符，空格不变。这一过程可描述为"如果字符是空白，原样打印；否则，打印原字符在ASCII序列中的下一个字符"。   
    [cypher1.c](../../c-example/cypher1.c)  

+ ctype.h系列的字符函数  
    C有一系列专门处理字符的函数，ctype.h头文件包含了这些函数的原型。这些函数接受一个字符作为参数，如果该字符属于某特殊的类别，就返回一个非零值；否则，返回0。例如，如果isalpha()函数的参数是一个字母，则返回一个非零值。如下：  
    [cypher2.c](../../c-example/cypher2.c)  
    
+ 多重选择else if  
    现实生活中我们经常有多种选择。在程序中也可以用else if扩展if else结构模拟这种情况。  

+ else与if配对  
    如果程序中有许多if和else，编译器如何知道哪个if对应哪个else？   
    规则是，如果没有花括号，else与离它最近的if匹配，除非最近的if被花括号括起来。  

+ 多层嵌套的if语句  
    前面介绍的if...else if...else序列是嵌套if的一种形式，从一系列选项中选择一个执行。有时，选择一个特定选项后又引出其他选择，这种情况可以使用另一种嵌套if。例如，程序可以使用if else选择男女，if else的每个分支里又包含另一个if else来区分不同收入的群体。   
    我们把这种形式的嵌套if应用在下面的程序中。给定一个整数，显示所有能整除它的约数。如果没有约数，则报告该数是一个素数。  
    在编写程序的代码之前要规划好。首先，要总体设计一下程序。

    1.  为方便起见，程序应该使用一个循环让用户能连续输入待测试的数。这样，测试一个新的数字时不必每次都要重新运行程序。  

    2.  下一步，设计如何找出约数。最直接的方法是：  

    ``` C
    for(div = 2; div < num; div++)
        if(num % div == 0)
            printf("%d is divisible by %d\n",num,div);
    ```

    3. 该循环检查2~num之间的所有数字，测试它们是否能被num整除。但是，这个方法有点浪费时间。可以改进一下，分析后发现，必须测试的书只要到num的平方根就可以了，不用到num。对于9这样的数字，不会节约很多时间，但是对于10000这样的数，使用哪一种方法求约数差别很大。不过，我们不用在程序中计算平方根，可以这样写测试条件：  

    ``` C
    for(div = 2; (div * div) <= num;div++)
        if(num % div == 0)
            printf("%d is divisible by %d and %d.\n",num,div,num/div);
    ```

    不使用平方根而用这样的测试条件，有两个原因。其一，整数乘法比求平方根快。其二，我们还没有正式介绍平方根函数。  

    4. 还有两个问题需要解决。第一个问题，如果待测试的数是一个完全平方数怎么办？报告144可以被12和12整除显得有点傻。可以使用嵌套if语句测试div是否等于num/div。如果是，程序只打印一个约数。第二个问题，如何知道一个数字是素数？如果num是素数，程序流不会进入if语句。要解决这个问题，可以在外层循环把一个变量设置为某个值，然后在if语句中把该变量重新设置为0.循环完成后，检查该变量是否是1，如果是，说明没有进入if语句，那么该数就是素数。这样的变量通常称为标记(flag)。  
    [divisors.c](../../c-example/divisors.c)  

#### 逻辑运算符

读者已经很熟悉了，if语句和while语句通常使用关系表达式作为测试条件。有时，把多个关系表达式组合起来会很有用。例如，要编写一个程序，计算输入的一行句子中除单引号和双引号以外其他字符的数量。这种情况下可以使用逻辑运算符，并使用句点(.)标识句子的末尾。   
[chcount.c](../../c-example/chcount.c)  

1. 备选拼写：iso646.h头文件  
    C是在美国用标准美式键盘开发的语言。但是在世界各地，并非所有的键盘都有和美式键盘一样的符号。因此，C99标准新增了可代替逻辑运算符的拼写，它们被定义在iso646.h头文件中。如果在程序中包含该头文件，便可用and代替&&、or代替||、not代替！。  

2. 优先级  
    !运算符的优先级很高，比乘法运算符还高，与递增运算符的优先级相同，只比圆括号的优先级低。&&运算符的优先级比||运算符高，但是两者的优先级都比关系运算符低，比赋值运算符高。  
3. 求值顺序  
    除了两个运算符共享一个运算对象的情况外，C通常不保证先对复杂表达式中哪部分求值。例如，下面的语句，可能先对表达式5 + 3求值，也可能先对表达式9 + 6求值：  
    
    >apples = (5+3) * (9+5)  

    C把先计算哪部分的决定权留给编译器的设计者，以便针对特定系统优化设计。但是，对于逻辑运算符是个例外，C保证逻辑表达式的求值顺序是从左往右。&&和||运算符都是序列点，所以程序在从一个运算对象执行到下一个运算对象之前，所有的副作用都会生效。而且，C保证一旦发现某个元素让整个表达式无效，便立即停止求值。  

4. 范围  
    &&运算符可用于测试范围。例如，要测试score是否在90~100的范围内，可以这样写：  

    ``` C
    if(range >= 90 && range <=  100)
        printf("Good show!\n");
    ```

    千万不要模仿数学上的写法：  

    ``` C
    if(90 <= range <=100)
        printf("Good show!\n");
    ```

    这样写的问题是代码有语义错误，而不是语法错误，所以编译器不会捕获这样的问题。由于<=运算分手的求值顺序是从左往右，所以编译器把测试表达式解释为：  
    (90 <= range) <= 100
    子表达式90 <= range的值要么是1，要么是0。这两个值都小于100，所以不管range的值是多少，整个表达式都恒为真。因此，在范围测试中要使用&&。  
    许多代码都用范围测试来确定一个字符是否小写字母。例如，假设ch是char类型的变量：  

    ``` C
    if(ch >= 'a'&&ch <= 'z')
        printf("That's a lowercase character.\n");
    ```

    该方法仅对于像ASCII这样的字符编码有效，这些编码中相邻字母与相邻数字一一对应。但是，对于像EBCDIC这样的代码就没有了。相应的可移植方法是，用ctype.h系列中的islower()函数：  

    ``` C
    if(islower(ch))
        printf("That's a lowercase character.\n");
    ```

    无论使用哪种特定的字符编码，islower()函数都能正常运行。   

#### 一个统计单词的程序

现在，我们可以编写一个统计单词数量的程序(即，该程序读取并报告单词的数量)。该程序还可以计算字符数和行数。先来看看编写这样的程序要涉及那些内容。  
首先，该程序要逐个字符读取输入，知道何时停止读取。然后，该程序能识别并计算这些内容：字符、行数和单词。  
[wordcnt.c](../../c-example/wordcnt.c)  

#### 条件运算符： ？ ：

C提供条件表达式(conditional expression)作为表达式if else语句的一种便捷方式 ，该 表达式使用? :条件运算符。该运算符分为两部分，需要3个运算对象。  
条件表达式的通用形式如下：  

>expression1 ? expression2 : expression3   

#### 循环辅助:continue和break

一般而言，程序进入循环后，在下一次循环测试之前会执行完循环体中的所有语句。continue和break语句可以根据循环体中的测试结果来忽略一部分循环内容，甚至结束循环。  

1. continue语句  
    3种循环都可以使用continue语句。执行到该语句时，会跳过本次迭代的剩余部分，并开始下一轮迭代。如果continue语句在嵌套循环内，则只会影响包含该语句的内层循环。  
    从何处开始继续循环？对于while和do while循环，执行continue语句后的下一个行为是对循环的测试表达式求值。对于for循环，执行continue后的下一个行为是对更新表达式求值，然后是对循环测试表达式求值。  

2. break语句  
    程序执行到循环中的break语句时，会终止包含它的循环，并继续执行下一阶段。  
    break还可用于因其他原因退出循环的情况。  
    在for循环中的break和continue的情况不同，执行完break语句后会直接执行循环后面的第1条语句，连更新部分也跳过。嵌套循环内层的break只会让程序跳出包含它的当前循环，要跳出外层循环还需要一个break；  

#### 多重选择：switch和breaak

使用条件运算符和if else语句很容易编写二选一的程序。然而，有时程序需要在多个选项中进行选择。可以用if else if...else来完成。但是，大多数情况下使用switch语句更方便。  

1. switch语句  
    要对紧跟在关键字switch后圆括号中的表达式求值。然后程序扫描标签列表，直到发现一个匹配的值为止。然后程序跳转至那一行。如果没有匹配的标签怎么办？如果有default:标签行，就跳转至该行；否则程序继续执行在switch后面的语句。  
    break语句在其中起什么作用？它让程序离开switch语句，跳至switch语句后面的下一条语句。如果没有break语句，就会从匹配标签开始执行到switch末尾。  
    switch在圆括号中的测试表达式的值应该是一个整数值(包括char类型)。case标签必须是整数类型的常量或整型常量表达式。不能用变量作为case标签。  

2. 只读每行的首字符  
    这种丢弃一行中其他字符的行为，经常出现在响应单字符的交互程序中。可以用下面的代码实现这样的行为：  

    ``` C 
    while(getchar()!='\n')
        continue;
    ```

    循环从输入中读取字符，包含按下Enter键产生的换行符。注意，函数的返回值并没有赋给ch，以上代码所做的只是读取并丢弃字符。由于最后丢弃的字符是换行符，所所以下一个被读取的字符是下一行的首字母。在外层的while循环中，getchar()读取首字母并赋给ch。  

3. 多重标签  
    如下程序所示，可以在switch语句中使用多重case标签。  
    [vowels.c](../../c-example/vowels.c)  

4. switch和if else  
    何时使用switch？何时使用if else？你经常会别无选择。如果根据浮点类型的变量或表达式来选择，就无法使用switch。如果根据变量在某范围内决定程序流的去向，使用switch就很麻烦，这种情况使用if就很方便。
 
#### goto语句

早期版本的BASIC和FORTRAN所依赖的goto语句，在C中仍然可用。但是C和其他两种语言不同，没有goto语句C程序也能运行良好。  
goto语句有两部分：goto和标签名。标签的命令遵循变量命名规则，如下所示：

>goto part2;

要让这条语句正常工作，函数还必须包含另一条标为part2的语句，该语句一标签名后紧跟一个冒号开始：  

>part2:printf("Refined analysis:\n");

1. 避免使用goto  
    原则上，根本不用在C程序中使用goto语句。但是，如果你曾经学过FORTRAN或BASIC，可能还会依赖用goto来编程。  
    但是C程序员可以接受一种goto的用法，出现问题时从一组嵌套循环中跳出(一条break语句只能跳出当前循环)

### 8. 字符输入/输出和输入验证

本章介绍以下内容：  
更详细地介绍输入、输出以及缓冲输入和无缓冲输入的区别  
如何通过键盘模拟文件结尾条件  
如何使用重定向把程序和文件相连接  
创建更友好的用户界面  

#### 单字符I/O：getchar()和puchar

之前提到过，getchar()和puchar()每次只处理一个字符。你可能认为这种方法实在太笨拙了，毕竟与我们的阅读方式相差甚远。但是，这种方法很适合计算机。而且，这是绝大多数文本(即，普通文字)处理程序所用的核心方法。如下程序，获取从键盘输入的字符，并把这些字符发送到屏幕上。程序使用while循环，当读到#字符时停止。  
[echo.c](../../c-example/echo.c)  
为何输入的字符能直接显示在屏幕上？如果用一个特殊字符(如，#)来结束输入，就无法在文本中使用这个字符，是否有更好的方法结束输入？要回答这些问题，首先要了解C程序如何处理键盘输入，尤其是缓冲和标准输入文件的概念。  

#### 缓冲区
如果在老式系统运行程序echo.c，你输入文本时可能显示如下：  

>HHeelllloo,,tthheerree..II wwoouulldd[enter]
>lliikkee aa#

以上行为是个例外。像这样回显用户输入的字符后立即重复打印该字符是属于无缓冲(或直接)输入，即正在等待的程序可立即使用输入的字符。对于该例，大部分系统在用户按下Enter键之前不会重复打印刚输入的字符，这种输入形式属于缓冲输入。用户输入的字符被收集并存储在一个被称为缓冲区(buffer)的临时存储区，按下Enter键后，程序才可使用用户输入的字符。两种输入的对比如下：  
![image](../../images/C-Learning/缓冲输入和无缓冲输入.png)

![缓冲输入和无缓冲输入.png](../../images/C-Learning/缓冲输入和无缓冲输入.png)  
为什么要有缓冲区？  

* 把若干字符作为一个块进行传输比逐个发送这些字符节约时间。  
* 如果用户打错字符，可以直接通过键盘修正错误。  

虽然缓冲输入好处很多，但是某些交互式程序也需要无缓冲输入。例如，在游戏中，你希望按下一个键就执行相应的指令。因此，缓冲输入和无缓冲输入都有用武之地。  
缓冲分为两类：完全缓冲I/O和行缓冲I/O。完全缓冲输入指的是当缓冲区被填满时才刷新缓冲区(内容被发送至目的地)，通常出现在文件输入中。缓冲区的大小取决于系统，常见的大小是512字节和4096字节。行缓冲I/O指的是在出现换行符时刷新缓冲区。键盘输入通常是行缓冲输入，所以在按下Enter键后才刷新缓冲区。  
那么，使用缓冲输入还是无缓冲输入？ANSI C和后续的C标准都规定输入时缓冲的，不过最初K&R把这个决定权交给了编译器的编写者。  
ANSI C决定把缓冲输入作为标准的原因是：一些计算机不允许无缓冲输入。如果你的计算机允许无缓冲输入，那么你所用的C编译器很可能会提供一个无缓冲输入的选项。例如，许多IBM PC兼容机的编译器都为支持无缓冲输入提供一系列特殊的函数，其原型都在conio.h头文件中。这些函数包括用于回显无缓冲输入的getche()函数和用于无回显无缓冲输入的getch()函数。UNIX系统使用另一种不同的方式控制缓冲。在UNIX系统中，可以使用ioctl()函数指定待输入的类型，然后用getchar()执行相应的操作。在ANSI C中，用setbuf()和setvbuf()函数控制缓冲，但是受限于一些系统的内部设置，这些函数可能不起作用。总之，ANSI没有提供调用无缓冲输入的标准方式，这意味着是否能进行无缓冲输入取决于计算机系统。  

#### 结束键盘输入

在echo.c程序中，只要输入的字符中不含#，那么程序在读到#时才会结束。但是，#也是一个普通的字符，有时不可避免要用到。应该用一个在文本中用不到的字符来标记输入完成，这样的字符不会无意间出现在输入中，在你不希望结束程序的时候终止程序。C的确提供了这样的字符，不过在此之前，先来了解一下C处理文件的方式。  

1. 文件、流和键盘输入  
    文件(file)是存储器中存储信息的区域。通常，文件都保存在某种永久存储器中(如，硬盘、U盘或DVD等)。毫无疑问，文件对于计算机系统相当重要。例如，你编写的C程序就保存在文件中，用来编译C程序的程序也保存在文件中。后者说明，某些程序需要访问指定的文件。当编译存储在名为echo.c文件中的程序时，编译器打开echo.c文件并读取其中的内容。当编译器处理完后，会关闭该文件。其他程序，例如文字处理器，不仅要打开、读取和关闭文件，还要把数据写入文件。  
    C是一门强大、灵活的语言，有许多用于打开、读取、写入和关闭文件的库函数。从较低层面上，C可以使用主机操作系统的基本文件工具直接处理文件，这些直接调用操作系统的函数被称为底层I/O(low-level I/O)。由于计算机系统各不相同，所以不可能为普通的底层I/O函数创建标准库，ANSI C也不打算这样做。然而从较高层面上，C还可以通过标准I/O包(standard I/O package)来处理文件。这涉及创建用于处理文件的标准模型和一套标准I/O函数。在这一层面上，具体的C实现负责处理不同系统的差异，以便用户使用统一的界面。  
    上面讨论的差异指的是什么？例如，不同的系统储存文件的方式不同。有些系统把文件的内容存储在一处，而文件相关的信息存储在另一处；有些系统在文件中创建一份文件描述。在处理文件方面，有些系统使用单个换行符标记行末尾，而其他系统可能使用回车符和换行符的组合来表示行末尾。有些系统用最小字节来衡量文件的大小，有些系统则以字节块的大小来衡量。  
    如果使用标准I/O包，就不用考虑这些差异。因此，可以用if(ch == '\n')检查换行符。即使系统实际用的是回车符和换行符的组合来标记行末尾，I/O函数会在两种表示法之间相互转换。  
    从概念上看，C程序处理的是流而不是直接处理文件。流(steam)是一个实际输入或输出映射的理想化数据流。这意味着不同属性和不同种类的输入，由属性更统一的流来表示。于是，打开文件的过程就是把流与文件相关联，而且读写都通过流来完成。  
    本章着重理解C把输入和输出设备视为存储设备上的普通文件，尤其是把键盘和显示设备视为每个C程序自动打开的文件。stdin流表示键盘输入，stdout流表示屏幕输出。getchar()、putchar()、printf()和scanf()函数不堵车标准I/O包的成员，处理这两个流。  

2. 文件结尾  
    计算机操作系统要以某种方式判断文件的开始和结束。检测文件结尾的一种方法是，在文件末尾放一个特殊的字符标记文件结尾。CP/M、IBM-DOS和MS-DOS的文本文件曾经使用过这种方法。如今，这些操作系统可以使用内嵌的Ctrl+Z字符来标记文件结尾。这曾经是操作系统使用的唯一标记，不过现在有一些其他的选择，例如记录文件的大小。所有现代的文本文件不一定有嵌入的Ctrl+Z,但是如果有，该操作系统会将其视为一个文件结尾标记。  
    操作系统使用的另一种方法是存储文件大小的信息。如果文件有3000字节，程序在读到3000字节时便达到文件的末尾。MS-DOS及其相关系统使用这种方法处理二进制文件，因为用这种方法可以在文件中存储所有的字符包括Ctrl+Z。新版的DOS也使用这种方法处理文本文件。UNIX使用这种方法处理所有的文件。  
    无论操作系统实际使用何种方法检测文件结尾，在C语言中，用getchar()读取文件检测到文件结尾时将返回一个特殊的值，即EOF(end of file的缩写)。scanf()函数检测到文件结尾时也返回EOF。通常，EOF定义在stdio.h文件中。  
    如何在程序中使用EOF？把getchar()的返回值和EOF作比较。如果两值不同，就说明没有达文件结尾。也就是说，可以使用下面这样的表达式:  

    ```C 
    while((ch = getchar())!=EOF)
    ```

    如果正在读取的是键盘输入不是文件会怎样？绝大部分系统都有办法通过键盘模拟文件结尾条件。了解这些以后，读者可以重写程序清单8.1的程序。  
    [echo_eof.c](../../c-example/echo_eof.c)  
    既然echo_eof.c程序能把用户输入的内容拷贝到屏幕上，那么考虑一下该程序还可以做什么。假设以某种方式把一个文件传送给它，然后它把文件中的内容打印在屏幕上，当到达文件结尾发现EOF信号时停止。或者，假设以某种方式把程序的输出定向到一个文件，然后通过键盘输入数据，用echo_eof.c来储存文件中输入的内容。假设同时使用这两种方法：把输入从一个文件定向到echo_eof.c中，并把输出发送至另一个文件，然后便可以使用echo_eof.c来拷贝文件。关键是要控制输入流和输出流，这是我们下一个要讨论的主题。  

#### 重定向和文件

输入和输出涉及函数、数据和设备。例如，考虑echo_eof.c，该程序使用输入函数getchar()。输入设备是键盘，输入数据流由字符组成。假设你希望输入函数和数据类型不变，仅改变程序查找数据的位置。那么，程序如何知道去哪里查找输入。  
在默认情况下，C程序使用标准I/O包查找标准输入作为输入源。这就是前面介绍过的stdin流，它是把数据读入计算机的常用方式。它可以是一个过时的设备，如磁带、穿孔卡或电传打印机，或者是键盘，甚至是一些先进技术，如语音输入。然而，现代计算机非常灵活，可以让它到别处查找输入。尤其是，可以让一个程序从文件中查找输入，而不是从键盘。  
程序可以通过两种方式使用文件。第1种方法是，显式使用特定的函数打开文件、关闭文件、读取文件、写入文件，诸如此类。在后续章节再详细介绍这种方法。第2种方法是，设计能与键盘和屏幕互动的程序，通过不同的渠道重定向输入至文件和从文件输出。换言之，把stdin流重新赋给文件。继续使用getchar()函数从输入流中获取数据，但它不关心从流的什么位置获取数据。虽然这种重定向的方法在某些方面有些限制，但是用起来比较简单，而且能让读者熟悉普通的文件处理技术。  
重定向的一个主要问题与操作系统有关，与C无关。尽管如此，许多C环境中(包括UNIX、Linux和Windows命令提示模式)都有重定向特性，而且一些C实现还在某些缺乏重定向特性的系统中模拟它。在UNIX上运行苹果OS X，可以用UNIX命令行模式启动Terminal应用程序。接下来介绍UNIX、Linux和Windows的重定向。  
UNIX(运行命令行模式时)、Linux(ditto)和Window命令行提示都能重定向输入、输出。重定向输入让程序使用文件而不是键盘输入，重定向输出让程序输出至文件而不是屏幕。  

1. 重定向输入  
    假设已经编译了echo_eof.c程序，并把可执行版本放入一个名为echo_eof的文件中。运行该程序，输入可执行文件名：echo_eof  
    该程序的运行情况和前面描述的一样，获取用户从键盘输入的输入。现在，假设你要用该程序处理名为words的文本文件。文本文件(text file)时内含文本的文件，其中储存的数据是我们可识别的字符。文件的内容可以是一篇散文或者C程序。内涵机器语言指令的文件(如存储可执行程序的文件)不是文本文件。由于该程序的操作对象是字符，所以要使用文本文件。  
    只需用下面的命令代替上面的命令即可：  

    ``` shell
    echo_eof<words  
    ```

    <符号是UNIX和DOS/Windows的重定向运算符。该运算符使words文件与stdin流相关联，把文件中的内容导入echo_eof程序。echo_eof程序本身并不知道输入的内容是来自文件还是键盘就，它只知道这是需要导入的字符流，所以它读取这些内容并把字符逐个打印在屏幕上，直至读到文件结尾。因为C把文件和I/O设备放在一个层面，所以文件就是现在的I/O设备放在一个层面，所以文件就是现在的I/O设备。

2. 重定向输出  
    现在假设要用echo_eof把键盘输入的内容发送到名为mywords的文件中。然后，输入以下命令并开始输入：  

    ``` shell
    echo_eof > mywords  
    ```

    \>符号是第2个重定向运算符。它创建了一个名为mywords的新文件，然后把echo_eof的输出重定向至该文件中。重定向把stdout从显示设备(显示器)赋给mywords文件。如果已经有一个名为mywords的文件，通常会擦除该文件的内容，然后替换新的内容。所有出现在屏幕的字母都是你刚才输入的，其副本存储在文件中。在下一行的开始处按下Ctrl+D或Ctrl+Z即可结束该程序。  

3. 组合重定向  
    现在，假设你希望制作一份mywords文件的副本，并命名为savewords。只需输入以下命令即可：  

    ``` shell
    echo_eof < mywords > savewords  
    ```

    下面的命令也起作用，因为命令与重定向运算符的顺序无关：  

    ``` shell
    echo_eof > savewords < mywords  
    ```

    在UNIX、Linux或Windows/DOS系统中使用两个重定向运算符(< 和 >)时，要遵循以下原则  

    * 重定向运算符连接一个可执行程序和一个数据文件  
    * 使用重定向运算符不能读取多个文件的输入，也不能把输出定向至多个文件  
    * 文件名和运算符之间的空格不是必须的  

    UNIX、Linux或Windows/DOS还有>>运算符，该运算符可以把数据添加到现有文件的末尾，而|运算符能把一个文件的输出连接到另一个文件的输入。  

#### 创建更友好的用户界面

1. 使用缓冲输入  
    缓冲输入用起来比较方便，因为在把输入发送给程序之前，用户可以编辑输入。但是，在使用输入的字符时，它也会给程序员带来麻烦。前面实例中看到的问题是，缓冲输入要求用户按下Enter键发送输入。这一动作也传送了换行符，程序必须妥善处理这个麻烦的换行符。我们以一个猜谜程序为例。用户选择一个数字，程序猜用户选中的数字是多少。该程序使用的方法单调乏味，先不要在意算法，我们关注的重点在输入和输出。如下：  
    [guess.c](../../c-example/guess.c)  
    注意，每次输入n时，程序打印了两条消息。这是由于程序读取n作为用户否定了数字1，然后还读取了一个换行符作为用户否定了数字2。  
    一种解决方案是，使用while循环丢弃输入行最后剩余的内容，包括换行符。这种方法的优点是，能把no和no way这样的响应视为简单的n。  
    
    ``` C 
    while(getchar()!='y')
    {
        printf("Well, then, is is %d?\n", ++guess);
        while(getchar() != '\n')
            continue;
    }
    ```

    这的确是解决了换行符的问题。但是，该程序还是会把f视为n。我们用if语句筛选其他响应。

    ``` C
    char response;
    while((response = getchar()) != 'y')
    {
        if(response == 'n')
            printf("Well, then, is it %d?\n", ++guess);
        else
            printf("Sorry, I understand only y or n.\n");
        while(getchar() != '\n')
            continue;
    }
    ```

2. 混合数值和字符输入  
    假设程序要求用getchar()处理字符输入，用scanf()处理数值输入，这两个函数都能很好地完成任务，但是不能把它们混用。因为getchar()读取每个字符，包括空格、制表符和换行符；而scanf()在读取数字时则会跳过空格、制表符和换行符。  
    [showchar1.c](../../c-example/showchar1.c)  
    while循环实现了丢弃scanf()输入后面所有字符(包括换行符)的功能，为循环的下一轮读取做好了准备。  

#### 输入验证

在实际应用中，用户不一定会按照程序的指令行事。用户的输入和程序期望的输入不匹配时常发生，这会导致程序运行失败。作为程序员，除了完成编程的本职工作，还要事先预料一些可能的输入错误，这样才能编写出能检测并处理这些问题的程序。  
假如，你编写了一个处理非负数整数的循环，但是用户很可能输入一个负数。你可以使用关系表达式来排除这种情况： 

``` C
long n;
scanf("%ld",&n);
while(n >= 0)
{
    //处理n  
    scanf("%ld",&n);//获取下一个值
}
```

另一类潜在的陷阱是，用户可能输入错误类型的值，如字符q。排除这种情况的一种方法是，检查scanf()的返回值。scanf()返回成功读取项的个数。因此，改进如下：  

``` C
long n;
while(scanf("%ld",&n) == 1 && n >= 0)
{
    //处理n
}
```

while循环条件可以描述为“当输入是一个整数且该整数为正时”。  
对于最后的例子，当用户输入错误类型的值是，程序结束。然而，也可以让程序友好些，提示用户再次输入正确类型的值。在这种情况下，要处理有问题的输入。如果scanf()没有成功读取，就会将其留在输入队列中。这里要明确，输入实际上是字符流。可以使用getchar()函数逐字符地读取输入，甚至可以把这些想法结合在一个函数中，如下：  

``` C
long get_long(void)
{
    long input;
    char ch;
    while(scanf("%ld",&input) != 1)
    {
        while((ch = getchar()) != '\n')
            putchar(ch);
        printf(" is not an integer.\nPlease enter an");            printf("integer value,such as 25,-178,or 3:");
    }
    return input;
}
```

该函数要把一个int类型的值读取变量input中。如果读取失败，函数则进入外层循环体。然后内层循环逐字符地读取错误的输入。注意，该函数丢弃该输入行的所有剩余内容。还有一个方法是，只丢弃下一个字符或单词，然后该函数提示用户再次输入。外层循环重复运行，直到用户成功输入整数，此时scanf()的返回值为1。  
在用户输入整数后，程序可以检查该值是否有效。考虑一个例子，要求用户输入一个上限和一个下限来定义值的范围。在该例中，你可能希望程序检查第1个值是否大于第2个值，除此之外还要检查这些值是否在允许的范围内。如下：  

``` C
bool bad_limits(long begin, long end, long low, long high)
{
    bool not_good = false;
    if(begin > end)
    {
        printf("%ld isn't smaller than %ld.\n",begin, end);
        not_good = true;
    }
    if(begin < low || end < low)
    {
        printf("Values must be %ld or greater.\n",low);
        not_good = true;
    }
    if(begin > high || end > high)
    {
        printf("Values must be %ld or less.\n",high);
        not_good = true;
    }
    return not_good;
}
```

下列函数使用了上述两个函数为一个进行算术运算的函数提供整数，该函数计算特定范围内所有整数的平方和。程序限制了范围的上限是10000000，下限是-10000000。  
[checking.c](../../c-example/checking.c)  
   
1. 分析程序  
    虽然checking.c核心的计算部分(sum_squares())很短，但是输入验证部分比以往程序实例要复杂。接下来分析其中的一些要素，先着重讨论程序的整体结构。  
    程序遵循模块化的编程思想，使用独立函数(模块)来验证输入和管理显示。程序越大，使用模块化编程就越重要。  
    main()函数管理程序流，为其他函数委派任务。它使用get_long()获取值、while循环处理值、badlimits()函数检查值是否有效、sum_squres()函数处理实际的计算。  

2. 输入流和数字  
    在编写处理错误输入的代码时，应该很清楚C是如何处理输入的。考虑下面的输入：  

    > is 28 12.4  

    在我们眼中，这就像是一个由字符、整数和浮点数组成的字符串。但是对C程序而言，这是一个字节流。第1个字节是字母i的字符编码，第2个字节是字母s的字符编码、第3个字节是空格字符的字符编码，第4个字节是数字2的字符编码，等等。所以，如果get_long()函数处理这一行输入，第1个字符是非数字，那么整行输入都会被丢弃，包括其中的数字，因为这些数字只是该输入行中的其他字符。  
    虽然输入流由字符组成，但是也可以设置scanf()函数把它们转换成数值。例如 42。  
    如果在scanf()函数中使用%c转换说明，它只会读取字符4并将其存储在char类型的变量中。如果使用%s转换说明，他会读取字符4和字符2这两个字符，并将其存储在字符数组中。如果使用%d转换说明，scanf()同样会读取两个字符，但是随后会计算出它们对应的整数值：4*10+2,即42，然后将表示该整数的二进制数储存在int类型的变量中。如果使用%f转换说明，scanf()也会读取两个字符，计算出它们对应的数值42.0，用内部的浮点表示法表示该值，并将结果储存在float类型的变量中。  
    简而言之，输入由字符组成，但是scanf()可以把输入转换成整数值或浮点数值。使用转换说明(如%d或%f)限制了可接受输入的字符类型，而getchar()和使用%c的scanf()接受所有的字符。

#### 菜单浏览

许多计算机程序都把菜单作为用户界面的一部分。菜单给用户提供方便的同时，却给程序员带来了一些麻烦。我们看看其中涉及了哪些问题。  
菜单给用户提供了一份响应程序的选项。假设有下面一个例子：  

>Enter the letter of your choice:  
>a. advice   b. bell  
>c. count    q. quit  

理想状态是，用户输入程序所列选项之一，然后程序根据用户所选项完成任务。作为一名程序员，自然希望这一过程能顺利进行。因此，第1个目标是：当用户遵循指令时程序顺利运行；第2个目标是：当用户没有遵循指令时，程序也能顺利运行。显而易见，要实现第2个目标难度较大，因为很难预料用户在使用程序时的所有错误情况。  
现在的应用程序通常使用图形界面，可以点击按钮、查看对话框、触摸图标，而不是我们实例中的命令行模式。但是，两者的处理过程大致相同：给用户提供选项、检查并执行用户的响应、保护程序不受误操作的影响。除了界面不同，它们底层的程序结构也几乎相同。但是，使用图形界面更容易通过限制选项控制输入。  

1. 任务  
    我们来更具体地分析一个菜单程序需要执行哪些任务。它要获取用户的响应，根据响应选择要执行的动作。另外，程序应该提供返回菜单的选项。C的switch语句是根据选项决定行为的好工具，用户的每个选择都可以对应一个特定的case标签。使用while语句可以实现重复访问菜单的功能。  

2. 使执行更顺利  
    当你决定实现这个程序时，就要开始考虑如何让程序顺利运行。例如，你能做的是让“获取选项”部分的代码筛选掉不合适的响应，只把正确的响应传入switch。这表明需要为输入过程提供一个只返回正确响应的函数。结合while循环和switch语句，其程序结构如下:  

    ``` C
    #include <stdio.h>
    char get_choice(void);
    void count(void);
    int main(void)
    {
        int choice;
        while((choice = get_choice()) != 'q')
        {
            switch(choice)
            {
                case 'a':
                    printf("Buy low,sell high.\n");
                    break;
                case 'b':
                    putchar('\a');
                    break;
                case 'c':
                    count();
                    break;
                default:
                    printf("Program error!\n");
                    break;
            }
        }
        return 0;
    }
    ```

    定义get_choice()函数只能返回'a'、'b'、'c'和'q'。get_choice()的用法和getchar()相同，两个函数都是获取一个值，并与终止值(该例子中是'q')作比较。我们尽量简化实际的菜单选项，以便读者把注意力集中在程序结构上。稍后再讨论count()函数。default语句可以方便调试。如果get_choice()函数没能把返回值限制为菜单指定的几个选项值，default语句有助于发现问题所在。  

    ``` C 
    char get_choice(void)
    {
        int ch;
        pirntf("Enter the letter of your choice:\n");
        printf("a. advice        b. bell\n");
        printf("c. count         q. quit\n");
        ch = getchar();
        while((ch < 'a' || ch > 'c') && ch != 'q')
        {
            printf("Please respond with a, b, c, or q.\n");
            ch = getchar();
        }
        return ch;
    }
    ```

    缓冲输入依旧带来些麻烦，程序把用户每次按下Return键产生的换行符视为错误响应。为了让程序的界面更流畅，该函数应该跳过这些换行符。  
    这类问题有多种解决方案。一种是用名为get_first()的新函数替换getchar()函数，读取一行的第一个字符并丢弃剩余的字符。这种方法的有点是，把类型act这样的输入视为简单的a，而不是继续吧act中的c作为选项c的一个有效的响应。  

    ``` C 
    char get_choice(void)
    {
        int ch;
        printf("Enter the letter of your choice:\n");
        printf("a. advice        b. bell\n");
        printf("c. count         q. quit\n");
        ch = get_first();
        while((ch < 'a' || ch > 'c') && ch != 'q')
        {
            printf("Please respond with a, b, c, or q.\n");
            ch = get_first();
        }
        return ch;
    }

    char get_first()
    {
        int ch;
        ch = getchar();
        while(getchar() ！= '\n')
            continue;
        return ch;
    }
    ```

3. 混合字符和数值输入  
    前面分析过混合字符和数值输入会产生一些问题，创建菜单也有这样的问题。例如，假设count()函数的代码如下：  

    ``` C
    void count(void)
    {
        int n,i;  
        printf("Count how far? Enter an integer:\n");
        scanf("%d",&n);
        for(i = 1; i <= n; i++)
            printf("%d\n",i);
    }
    ```  

    如果输入3作为响应，scanf()会读取3并把换行符留在输入队列中。下次调用get_choice()将导致get_first()返回这个换行符，从而导致我们不希望出现的行为。  
    重写get_first()，使其返回下一个非空白字符而不仅仅是下一个字符，即可修复这个问题。另一种方法是，在count()函数中清理换行符，如下：  

    ``` C 
    void count(void)
    {
        int n, i;
        printf("Count how far? Enter an integer:\n");
        n = get_int();
        for(i = 1; i <= n; i++)
            printf("%d\n", i);
        while(getchar() != '\n')
            continue;
    }
    ```

    最后的菜单程序如下：  
    [menuette.c](../../c-example/menutte.c)  

### 9. 函数

本章介绍以下内容：  
关键字：return  
运算符：*(一元)、&(一元)  
函数及其定义方式  
如何使用参数和返回值  
如何把指针变量用作函数参数  
函数类型  
ANSI C原型  
递归  
如何组织程序？C的设计思想是，把函数用作构件块。我们已经用过C标准库的函数，如printf()、scanf()、getchar()、putchar()和strlen()。现在要进一步学习如何创建自己的函数。前面章节已大致介绍了相关过程，本章将巩固以前学过的知识并作进一步的拓展。  

#### 复习函数

首先，什么是函数？函数(function)是完成特定任务的独立程序代码单元。语法规则定义了函数的结构和使用方式。虽然C中的函数和其他语言中的函数、子程序、过程作用相同，但是细节上略有不同。一些函数执行某些动作，如printf()把数据打印到屏幕上；一些函数找出一个值供程序使用，如strlen()把指定字符串的长度返回给程序。一般而言，函数可以同时具备以上两种功能。  
为什么要使用函数？首先，使用函数可以省去编写一个合适的函数，就可以在需要时使用这个函数，或者在不同的程序中使用该函数，就像许多程序中使用putchar()一样。其次，即使程序只完成某项任务一次，也值得使用函数。因为函数让程序更加模块化，从而提高了程序代码的可读性，更方便后期修改、完善。例如，假设要编写一个程序完成以下任务：  
读入一系列数字；  
分类这些数字；  
找出这些数字的平均值；  
打印一份柱状图。  
可以使用下面的程序  

``` C
#include <stdio.h>
#define SIZE 50
int main(void)
{
    float list[SIZE];
    readlist(list,SIZE);
    sort(list,SIZE);
    average(list,SIZE);
    bargraph(list,SIZE);
    return 0
}
```

当然，还要编写四个函数readlist()、sort()、average()和bargraph()的实现细节。描述性的函数名能清楚地表达函数的用途和组织结构。然后，单独设计和测试每个函数，直到函数都能正常完成任务。如果这些函数够通用，还可以用于其他程序。  
许多程序员喜欢把函数看作是根据传入信息(输入)及其生成的值或响应的动作(输出)来定义的“黑盒”。如果不是自己编写函数，根本不用关心黑盒的内部行为。例如，使用printf()时，只需要知道给该函数传入格式字符串或一些参数以及printf()生成的输出，无需了解printf()的内部代码。以这种方式看待函数有助于把注意力集中在程序的整体设计，而不是函数的实现细节上。因此，在动手编写代码之前，仔细考虑一下函数应该完成什么任务，以及函数和程序整体的关系。  
如何了解函数？首先要知道如何正确地定义函数、如何调用函数和如何建立函数间的通信。我们从一个简单的程序实例开始。  

1. 创建并使用简单函数  
    我们的第1个目标是创建一个在一行打印40个星号的函数，并在一个打印表头的程序中使用该函数。如下：  
    [lethead1.c](../../c-example/lethead1.c)  

2. 分析程序  
    该程序要注意以下几点。  
    程序在3处使用了starbar标识符：函数原型(function prototype)告诉编译器函数starbar()的类型；函数调用(function call)表明在此处执行函数；函数定义(function definition)明确地指定了函数要做什么。  
    函数和变量一样，有多种类型。任何程序在使用函数之前都有声明该函数的类型。因此，在main()函数定义的前面出现了下面的ANSI C风格的函数原型：  

    >void starbar(void)

    圆括号表明starbar是一个函数名。第一个void是函数类造型，void类型表明函数没有返回值。第2个void(在圆括号中)表明该函数不带参数。分号表明这是声明函数，不是定义函数。也就是说，这行声明了程序将使用一个名为starbar()、没有返回值、没有参数的函数，并告诉编译器在别处查找该函数的定义。对于不识别ANSI C风格原型的编译器，只需声明函数的类型。  
    一般而言，函数原型指明了函数的返回值类型和函数接受的参数类型。这些信息称为该函数的签名(signature)。对于starbar()函数而言，其签名是该函数没有返回值，没有参数。  
    程序把starbar()原型置于main()的前面。当然，也可以放在main()里面的声明变量处。放在哪个位置都可以。  
    在main()中，执行到下面的语句时调用了starbar()函数：  

    >starbar();

    这是调用void类型函数的一种形式。当计算机执行到starbar();语句时，会找到该函数的定义并执行其中的内容。执行完starbar()中的代码后，计算机返回主调用函数(calling function)继续执行下一行，如下图：  
    ![lethead1程序流.png](../../images/C-Learning-two/lethead1程序流.png)  

    程序中starbar()和main()的定义形式相同。首先函数头包括函数类型、函数名和圆括号，接着是左花扩号、变量声明、函数表达式语句，最后以右花括号结束。如下图。注意，函数头中的starbar()后面没有分号，告诉编译器这是定义starbar()，而不是调用函数或声明函数原型。  
    ![简单函数结构.png](../../images/C-Learning-two/简单函数结构.png)  

    程序把starbar()和main()放在一个文件中。当然，也可以把它们分别放在两个文件中。把函数都放在一个文件中的单文件形式比较容易编译，而使用多个文件方便再不同的程序中使用同一个函数。如果把函数放在一个单独的文件中，要把#define和#include指令也放入该文件。现在，先把所有的函数都放在一个文件中。main()的右花括号告诉编译器该函数结束的位置，后面的starbar函数头告诉编译器starbar()是一个函数。  
    starbar()函数中的变量count是局部变量(local variable)，意思是该变量只属于starbar()函数。可以在程序中的其他地方(包括main()中)使用count，这不会引起名称冲突，它们是同名的不同变量。  

3. 函数参数  
    如果程序lethead1.c的输出中，文字能居中，信头会更加美观。可以通过在打印文字之前打印一定数量的空格来实现，这和打印一定数量的星号(starbar()函数)类似，只不过现在要打印的是一定数量的空格。虽然这是两个任务，但是任务非常相似，与其分别为它们编写一个函数，不如写一个更通用的函数，可以在两种情况下使用。我们设计一个新的函数show_n_char()（显示一个字符n次）。唯一要改变的是使用内置的值来显示字符和重复的次数，show_n_char()将使用函数参数来传递这些值。  
    具体分析。假设可用的空间是40个字符宽。调用show_n_char('\*',40)应该正好打印一行40个星号，就像starbar()之前做的那样。第二行GIGATHINK，INT.的空格怎么处理？GIGATHINK, INT.是15个字符宽，所以第一个版本中，文字后面有25个空格。为了让文字居中，文字的左侧应该有12个空格，右侧有13个空格。因此，可以调用show_n_char('\*',12)。  
    show_n_char()与starbar()很相似，但是show_n_char()带有参数。从功能上看，前者不会添加换行符，而后者会，因为show_n_char()带有参数。从功能上看，前者不会添加换行符，而后者会，因为show_n_char()要把空格和文本打印成一行。修改后的程序如下：  
    [lethead2.c](../../c-example/lethead2.c)  

4. 定义带形式参数的函数  
    函数定义从下面的ANSI C风格的函数头开始：  

    >void show _n_char(char ch,int num)

    该行告知编译器show_n_char()使用两个参数ch和num，ch是char类型，num是int类型。这两个变量被称为形式参数(formal argument,但是最近的标准推荐使用formal parameter),简称形参。和定义在函数中变量一样，形式参数也是局部变量，属该函数私有。这意味着其他函数中使用同名变量不会引起名称冲突。每次调用函数，就会给这些变量赋值。  
    注意，ANSI C要求在每个变量前都声明其类型。也就是说，不能像普通变量声明那样使用同一类型的变量列表：  
    >void dibs(int x,y,z) /\*无效函数头\*/
    >void dubs(int x,int y,int z) /\*有效函数头\*/  

    虽然show_n_char()接受来自main()的值，但是它没有返回值。因此，show_n_char()的类型是void。

5. 声明带形式参数函数的原型  
    在使用函数之前，要用ANSI C形式声明函数原型：  

    >void show_n_char(char ch,int num)

    当函数接收参数时，函数原型用逗号分隔的列表指明参数的数量和类型。根据个人喜好，你也可以省略变量名：  
    在原型中使用变量名并没有实际创建变量，char仅代表了一个char类型的变量，以此类推。再次提醒读者注意，ANSI C也接受过去的声明函数形式，即圆括号内没有参数列表： void show_n_char();  

6. 调用带实际参数的函数  
    在函数调用中，实际参数(actual argument,简称实参)提供了ch和num的值。考虑程序lethead2.c中第1次调用show_n_char():  

    >show_n_char(SPACE,12);

    实际参数是空格字符和12。这两个值被赋给show_n_char()中相应的形式参数：变量ch和num。简而言之，形式参数是被调函数(called function)中的变量，实际参数是主调函数(calling function)赋给被调函数的具体值。如上例所示，实际参数可以是常量、变量，或甚至是更复杂的表达式。无论实际参数是何种形式都要被求值，然后该值被拷贝给被调函数相应的形式参数。以lethead2.c中最后一次调用show_n_char()为例：  

    >show_n_char(SPACE,(WIDTH-strlen(PLACE)/2))  

    构成该函数第2个实际参数的是一个很长的表达式，对该表达式求值为10。然后，10被赋给变量num。被调函数不知道也不关心传入的数值是来自常量、变量还是一般表达式。再次强调，实际参数是具体的值，该值要被赋给作为形式参数的变量。因为被调函数使用的值是从主调函数中拷贝而来，所以无论被调函数对拷贝数据进行什么操作，都不会影响主调函数中的原始数据。  
    ![形式参数和实际参数.png](../../images/C-Learning-two/形式参数和实际参数.png)  

    注意 实际参数和形式参数  
    实际参数是出现在函数调用圆括号中的表达式。形式参数是函数定义的函数头中声明的变量。调用函数时，创建了声明为形式参数的变量并初始化为实际参数的求值结果。在程序lethead2.c中，'*'和WIDTH都是第1次调用show_n_char()时的实际参数，而SPACE和11是第2次调用show_n_char()时的实际参数。在函数定义中，ch和num都是该函数的形式参数。  

7. 黑盒视角  
    从黑盒视角看show_n_char()，待显示的字符和显示的次数是输入。执行后的结果是打印指定数量的字符。输入以参数的形式被传递给函数。这些信息清楚地表明了如何在main()中使用该函数。而且，这也可以作为编写该函数的设计说明。  
    黑盒方法的核心部分是：ch、num和count都是show_n_char()私有的局部变量。如果在main()中使用同名变量，那么它们相互独立，互不影响。也就是说，如果main()有一个count变量，那么改变它的值不会改变show_n_char()中的count，反之亦然。黑盒里发生了什么对主调函数是不可见的。  

8. 使用return从函数中返回值  
    前面介绍了如何把信息从主调函数传递给被调函数。反过来，函数的返回值可以把信息从被调函数传回主调函数。为进一步说明，我们将创建一个返回两个参数中较小值的函数。由于函数被设计用来处理int类型的值，所以被命名为imin()。另外，还要创建一个简单的main()，用于检查imin()是否正常工作。这种被设计用于测试函数的程序有时被称为驱动程序(driver)，该驱动程序调用一个函数。如果函数成功通过了测试，就可以安装在一个更重要的程序中使用。如下程序所示：  
    [lesser.c](../../c-example/lesser.c)  

    关键字retrun后面的表达式的值就是函数的返回值。在该例中，该函数返回的值就是变量min的值。因为min是int类型的变量，所以imain()函数的类型也是int。  
    变量min属于imain()函数私有，但是return语句把min的值传回了主调函数。下面这条语句的作用是把min的值赋给lesser:  

    >lesser = imin(n,m)  

    是否能像写成下面这样：  

    >imin(n,m);  
    >lesser = min;

    不能。因为主调函数甚至不知道min的存在。记住，imin()中的变量是imin()的局部变量。函数调用imin(evil1,evil2)只是把两个变量的值拷贝了一份。  
    返回值不仅可以赋给变量，也可以被用作表达式的一部分。例如，可以这样：  

    >answer = 2 * imin(z,zstar) + 25;
    >printf("%d\n",imin(-32+answer,LIMIT));

    返回值不一定是变量的值，也可以是任意表达式的值。例如，可以用以下的代码简化程序示例：  

    ``` C
    imin(int n, int m)
    {
        return (n < m)? n : m;
    }
    ```

    条件表达式的值是n和m中的较小者，该值要被返回给主调函数。虽然这里不要求用原括号把返回值括起来，但是如果想让程序条理更清楚或统一风格，可以把返回值放在圆括号内。  
    如果函数返回值的类型与函数声明的类型不匹配会怎样？  

    ``` C
    int what_if(int n)
    {
        double z = 100.0 / (double) n;
        return z;
    }
    ```

    实际得到的返回值相当于把函数中指定的返回值赋给与函数类型相同的变量所得到的值。因此在本例中，相当于把z的值赋给int类型的变量，然后返回int类型变量的值。例如，假设有下面的函数调用：  

    >result = what_if(64);

    虽然在what_if()函数中赋给z的值是1.5625，但是return语句返回却是int类型的值1。  
    使用return语句的另一个作用是，终止函数并把控制返回给主调函数的下一条语句。因此，可以这样编写imin():  

    ``` C
    imin(int n, int m)
    {
        if(n < m)
            return n;
        else
            return m;
    }
    ```

    许多C程序员都认为只在函数末尾使用一次return语句比较好，因为这样做更方便浏览程序的人理解函数的控制流。但是，在函数中使用多个return语句也没有错。无论如何，对用户而言，这3个版本的函数用起来都一样，因为所有的输入和输出都完全相同，不同的是函数内部的实现细节。下面的版本也没问题：

    ``` C
    imin(int n,int m)
    {
        if(n < m)
            return n;
        else
            return m;
        printf("Professor Fleppard is like totally a fopdoodle.\n");
    }
    ```

    return语句导致printf()语句永远不会被执行。  

9. 函数类型  
    声明函数时必须声明函数的类型。带返回值的函数类型应该与其返回值类型相同，而没有返回值的类型应声明为void类型。如果没有声明函数的类型，旧版本的C编译器会假定函数的类型是int。这一惯例源于C的早期，那时的函数绝大多数都是int类型。然而，C99标准不再支持int类型函数的这种假定设置。  
    类型声明是函数定义的一部分。要记住，函数类型指的是返回值的类型，不是函数参数的类型。例如，下面的函数头定义了一个带两个int类型参数的函数，但是其返回值是double类型。  

    >double klink(int a,int b)

    要正确地使用函数，程序在第1次使用函数之前必须知道函数的类型。方法之一是，把完整的函数定义放在第1次调用函数的前面。然而，这种方法增加了程序的阅读难度。而且，要使用的函数可能在C库或其他文件中。因此，通常的做法是提前声明函数，把函数的信息告知编译器。  

#### ANSI C函数原型
在ANSI C标准之前，声明函数的方案有缺陷，因为只需要声明函数的类型，不用声明任何参数。下面我们看一下使用旧式的函数声明会导致什么问题。  
下面是ANSI之前的函数声明，告知编译器imin()返回int类型的值：  

>int imin();

然而，以上函数声明并未给出imin()函数的参数个数和类型。因此，如果调用imin()时使用的参数个数不对或类型不匹配，编译器根本不会察觉出来。  

1. 问题所在  
    我们看看与imax()函数相关的一些示例，该函数与imin()函数关系密切。下面演示了一个程序，用过去声明函数的方式声明了imax()函数，然后错误地使用该函数。  
    [misuse.c](../../c-example/misuse.c)  
    这两个编译器都运行正常，之所以输出错误的结果，是因为它们运行的程序没有使用函数原型。  
    由于不同系统的内部机制不同，所以出现问题的具体情况也不同。下面介绍的是使用PC和VAX的情况。主调函数把它的参数储存在被称为栈的临时存储区，被调函数从栈中读取这些参数。对于该例，这两个过程并未相互协调。***主调函数根据函数调用中的实际参数决定传递的类型，而被调函数根据它的形式参数读取值***。因此，函数调用imax(3)把一个整数放在栈中。当imax()函数开始执行时，它从栈中读取两个整数。而实际上栈中只存放了一个待读取的整数，所以读取的第2个值是当时恰好在栈中的其他值。  
    第2次使用imax()函数时，它传递的是float类型的值。这次把两个double类型的值放在栈中。在我们的系统中，两个double类型的值就是两个64位的值，所以128位的数据被放在栈中。当imax()从栈中读取两个int类型的值时，他从栈中读取前64位。在我们的系统中，每个int类型的变量占用32位。这些数据对应两个整数，其中较大的市3886。  

2. ANSI的解决方案  
    针对参数不匹配的问题，ANSI C标准要求在函数声明时还要声明变量的类型，即使用函数原型(function prototype)来声明函数的返回类型、参数的数量和每个参数的类型。未标明imax()函数有两个int类型的参数，可以使用下面两种函数的原型来声明：  

    >int imax(int,int);
    >int imax(int a, int b);

    第1中形式使用以逗号分隔的类型列表，第2种形式在类型后面添加了变量名。注意，这里的变量名是假名，不必与函数定义的形式参数名一致。  
    有了这些信息，编译器可以检查函数调用是否与函数原型匹配。参数的数量是否正确？参数的类型是否匹配？以imax()为例，如果两个参数都是数字，但是类型不匹配，编译器会把实际参数的类型转换成形式参数的类型。例如，imax(3.0,5.0)会被转换成imax(3,5)。我们用函数原型替换misuse.c程序，如下：  
    [proto.c](../../c-example/proto.c)  
    如上文所述，第2次调用中的3.0和5.0被转换成3和5，以便函数能正确地处理输入。  
    虽然没有错误消息，但是我们的编译器还是给出了警告：double转换成int可能会导致丢失数据。  
    错误和警告的区别是：错误导致无法编译，而警告仍然允许编译。一些编译器在进行类似的类型转换时不会通知用户，因为C标准中对此未作要求。不过，许多编译器都允许用户选择警告级别来控制编译器在描述告警时的详细程度。  

3. 无参数和未指定参数  
    假设有下面的函数原型：  

    >void print_name();

    一个支持ANSI C的编译器会假定用户没有用函数原型来声明函数，它将不会检查参数。为了表明函数确实没有参数，应该在圆括号中使用void关键字：  

    >void print_name(void);  

    支持ANSI C的编译器解释为print_name()不接受任何参数。然后在调用该函数时，编译器会检查以确保没有使用参数。  
    一些函数接受(如，printf()和scanf())许多参数。例如对于printf()，第1个参数是字符串，但是其余参数的类型和数量都不固定。对于这种情况，ANSI C允许使用部分原型。例如，对于printf()可以使用下面的原型：  

    >int printf(const char*,...);  

    这种原型表明，第1个参数是一个字符串，可以还有其他未指定的参数。  
    C库通过stdarg.h头文件提供了一个定义这类函数的标准方法。  

4. 函数原型的优点  

    函数原型是C语言的一个强有力的工具，它让编译器捕获在使用函数时可能出现的许多错误或疏漏。如果编译器没有发现这些问题，就很难觉察出来。是否必须使用函数原型？不一定。你也可以使用旧式的函数声明(即不用声明任何形参),但是这样做的弊大于利。  
    有一种方法可以省略函数原型却保留函数原型的优点。首先要明白，之所以使用函数原型，是为了让编译器在第1次执行到该函数之前就知道如何使用它。因此，把整个函数定义放在第1次调用该函数之前，也有相同的效果。此时，函数定义也相当于函数原型。对于较小的函数，这种用法很普遍：  

    ```C
    int imax(int a, int b){return a > b ? a : b;}
    int main()
    {
        int x, z;
        ...
        z = imax(x, 50);
        ...
    }
    ```

#### 递归
C允许函数调用它子集，这种调用过程称为递归(recursion)。递归有时难以琢磨，有时却很方便实用。结束递归是使用递归的难点，因为如果递归代码中没有终止递归的条件测试不分，一个调用自己的函数会无限递归。  
可以使用循环的地方通常都可以是用递归。有时用循环解决问题比较好，但是有时用递归更好。递归方案更简洁，但效率却没有循环高。  

1. 演示递归  
    我们通过一个程序，来学习什么是递归。成勋recur.c中的main函数调用up_and_down()函数，这次调用称为“第1级递归”。然后up_and_down()调用自己，这次调用称为“第2级递归”。接着第2级递归调用第3级递归，依此类推。该程序实例共有4级递归。为了进一步深入研究递归时发生了什么，程序不仅显示了变量n的值，还显示了储存n的内存地址&n。  
    [recur.c](../../c-example/recur.c)  
    我们来仔细分析程序中的递归是如何工作的。首先，main()调用了带参数1的up_and_down()函数，执行结果是up_and_down()中的形式参数n的值是1，所以打印语句#1打印Level 1。然后由于n小于4，up_and_down()(第1级)调用实际参数为n+1的up_and_down()(第2级)。于是第2级调用中的n的值是2，打印语句#1打印Level2。与此类似，下面两次调用打印的分别是Level3和Level4。  
    当执行到第4级时，n的值是4，所以if测试条件为假。up_and_down()函数不在调用自己。第4级调用接着执行打印语句#2，即打印LEVLE 4，因为n的值是4。此时，第4级调用结束，控制被传回它的主调函数(即第3级调用)。在第3级调用中，执行的最后一条语句是调用if语句中的第4级调用。被调函数(第4级调用)把控制返回在这个位置，因此，第3级调用继续执行后面的代码，打印语句#2打印LEVEL 3。然后第3级调用结束，控制被传回第2级调用，接着打印LEVLE 2，依此类推。  
    注意，每级递归的变量n都属于本级递归私有。这从程序输出的地址值可以看出(当然，不同的系统表示的地址格式不同，这里关键要注意Level 1和LEVEL 1的地址相同，等等)。  
    如果觉得不好理解，可以假设有一条函数调用链——fun1()调用fun2()、fun2()调用fun3()、fun3调用fun4()。当fun4()结束时，控制传回fun3();当fun3()结束时，控制传回fun2();当fun2()结束时，控制传回fun1()。递归的情况与此类似，只不过fun1()、fun2()、fun3()和fun4()都是相同的函数。  

2. 递归的基本原理  
    初次接触递归会觉得较难理解。为了帮助读者理解递归过程，下面以程序清单recur.c为例讲解几个要点。  
    第1，每级函数调用都有自己的变量。也就是说，第1级的n和第2级的n不同，所以程序创建了4个单独的变量，每个变量名都是n，但是它们的值各不相同。当程序最终返回up_and_down()的第1级调用时，最初的n仍然是它的初值1。  
    ![递归中的变量.png](../../images/C-Learning-two/递归中的变量.png)  
    第2，每次函数调用都会返回一次。当函数执行完毕后，控制权将被传回上一级递归。程序必须按顺序逐级返回递归，从某级up_and_down()返回上一级的up_and_down()，不能跳级回到main()中的第一级调用。  
    第3，递归函数中位于递归调用之前的语句，均按被调函数的顺序执行。例如，程序清单recur.c中的打印语句#1位于递归调用之前，它按照递归的顺序：第1级、第2级、第3级和第4级，被执行了4次。  
    第4，递归函数中位于递归调用之后的语句，均按被调函数相反的顺序执行。例如，，打印语句#2位于递归调用之后，其执行的顺序是第4级、第3级、第2级、第1级。递归调用的这种特性在解决涉及相反顺序的编程问题时很有用。  
    第5，虽然每级递归都有自己的变量，但是并没有拷贝函数的代码。程序按顺序执行函数中的代码，而递归调用就相当于又从头开始执行函数的代码。除了为每次递归调用创建变量外，，递归调用非常类似于一个循环语句。实际上，递归有时可用循环来代替，循环有时也能用递归来代替。  
    最后，递归函数必须包含能让递归调用停止的语句。通常，递归函数都使用if或其他等价的测试条件在函数形参等于某特定值时终止递归。为此，每次递归调用的形参都要使用不同的值。例如，程序recur.c中的up_and_down()调用up_and_down(n+1)。最终，实际参数等于4时，if的测试条件(n<4)为假。  

3. 尾递归  
    最简单的递归形式是把递归调用置于函数的末尾，即正好在return语句之前。这种形式的递归被称为尾递归(tail recursion)，因为递归调用在函数的末尾。尾递归是最简单的递归形式，因为它相等于循环。  
    下面要介绍的程序示例中，分别用循环和尾递归计算阶乘。一个正整数的阶乘(factorial)是从1到该整数的所有整数的乘积。例如，3的阶乘(写作3！)是1*2*3。另外，0！等于1，负数没有阶乘。下列程序中，第1个函数使用for循环计算阶乘，第2个函数使用递归计算阶乘。  
    [factor.c](../../c-example/factor.c)  
    测试程序把输入限制在0~12。因为12!已快接近5亿，而13!比62亿还大，已超过系统中long类型能表示的范围。要计算超过12的阶乘，必须使用能表示更大范围的类型，如double或long long。
    使用循环的函数把ans初始化为1，然后把ans与从n~2的所有递减整数相乘。根据阶乘的公式，还应该乘以1，但是这并不会改变结果。  
    现在考虑使用递归的函数。该函数的关键是n! = n*(n-1)!。可以这样做是因为(n-1)!是n-1~1的所有正整数的乘积。因此，n乘以n-1就得到n的阶乘。阶乘的这一特性很适合使用递归。如果调用函数rfact()，rfact(n)是n*rfact(n-1)。因此，通过调用rfact(n-1)来计算rfact(n)，如程序中所示。当然要在满足某条件时结束递归，可以在n等于0时把返回值设为1。  
    程序中使用递归的输出和使用循环的输出相同。注意，虽然rfact()的递归调用不是函数的最后一行，但是当n>0时，它是该函数执行的最后一条语句，因此它也是尾递归。  
    既然用递归和循环来结算都没问题，那么到底应该使用哪一个？一般而言，选择循环比较好。首先，每次递归都会创建一组变量，所以递归使用的内存更多，而且每次递归调用都会把创建的一组新变量放在栈中。递归调用的数量受限于内存空间。其次，由于每次函数调用要花费一定的时间，所以递归的执行速度较慢。那么，演示这个程序的目的是什么？因为尾递归是递归中最简单的形式，比较容易理解。在某些情况下，不能用简单的循环代替递归，因此读者还是要好好理解递归。  
    
4. 递归和倒序计算  
    递归在处理倒序时非常方便(在解决这类问题中，递归比循环简单)。我们要解决的问题是：编写一个函数，，打印一个整数的二进制数。  
    我们要设计一个以二进制形式表示整数的方法或算法。例如，如何用二进制表示十进制5？在二进制中，奇数的末尾一定是1，偶数的末尾一定是0，所以通过5%2即可确定5的二进制数的最后一位是1还是0。一般而言，对于数字n，其二进制的最后以为是n%2。因此，计算的第一位数字实际上是待输出二进制数的最后一位。这一规律提示我们，在递归函数的递归调用之前计算n%2，，在递归调用之后打印计算结果。这样，计算的第1个值正好是最后一个打印的值。  
    要获得下一位数字，必须把原数除以2。这种计算方法相当于在十进制下把小数点左移一位，如果计算结果是偶数，那么二进制的下一位数就是0；如果是奇数，就是1。例如，5/2得2，2是偶数,所以下一位二进制数是0。到目前为止，我们已经获得01。继续重复这个过程。2/2得1，1%2得1，所以下一位二进制数是1。因此，我们得到5的等价二进制数是101。那么，程序应该如何停止计算？当与2相除的结果小于2时停止计算，因为只要结果大于或等于2，就说明还有二进制位。每次除以2就相等于去掉一位二进制，直到计算出最后一位为止。  
    [binary.c](../../c-example/binary.c)  
    不用递归，是否能实现这种二进制形式表示整数的算法？当然可以。但是由于这种算法要首先计算最后一位二进制数，所以在显示结果之前必须把所有的 位数都储存在别处(如：数组)。  

5. 递归的优缺点  
    递归既有优点也有缺点。优点是递归为某些编程问题提供了简单的解决方案。缺点是一些递归算法会快速消耗计算机的内存资源。另外，递归不方便阅读和维护。  
    斐波拉契数列的定义如下：第1个和第2个数字都是1，而后续的每个数字都是其前两个数字之和。例如，该数列的前几个数是：1、1、2、3、5、8、13。斐波拉契数列在数学界深受喜爱，甚至有专门研究它的刊物。下面，创建一个 函数，接受正整数n，返回相应的斐波拉契数值。  
    首先，来看递归。递归提供一个简单的定义。如果把函数命名为Fibonacci(),那么如果n是1或2，Fibonacci(n)应返回1：对于其他数值，则应返回Fibonacci(n-1)+Fibonacci(n-2):  

    ``` C
    unsigned long Fibonacci(unsigned n)
    {
        if(n > 2)
            return Fibonacci(n-1) + Fibonacci(n-2);
        else
            return 1;
    }
    ```

    这个递归函数只是重述了数学定义的递归。该函数使用了双递归(double recursion),即函数每一级递归都要调用本身两次。这暴露了一个问题。  
    变量的数量呈指数增长！按指数增长很快就会产生非常大的值。很快就消耗掉计算机的大量内存，很可能导致程序崩溃。  
    虽然这是个极端的例子，但是该例说明：在程序中使用递归要特别注意，尤其是效率优先的程序。  
    所有的C函数皆平等。  
    程序中的每个 C函数与其他函数都是平等的。每个函数都可以调用其他函数，或被 其他函数调用。  
    main()函数是否与其他函数不同？是的，main()的确有点特殊。当main()与程序中的其他函数放在一起时，最开始执行的是main()函数中的第1条语句，但是这也是局限之处。main()也可以被自己或其他函数递归调用。  
    
#### 编译多源代码文件的程序
使用多个函数最简单的方法是把它们都放在同一个文件中，然后像编译只有一个函数的文件那样编译该文件即可。其他因操作系统而异。   

1. UNIX  
    假定在UNIX系统中安装了UNIX C编译器cc(最初的cc已经停用，但是许多UNIX系统都给cc命令起了一个别名用作其他编译器命令，典型的是gcc或clang)。假设file1.c和file2.c是两个内含C函数的文件，下面的命令将编译两个文件并生成一个名为a.out的可执行文件：  

    >cc file1.c file2.c   

    另外，还生成两个名为file1.o和file2.o的目标文件。如果后来改动了file1.c，而file2.c不变，可以使用以下命令编译第1个文件，并与第2个文件的目标代码合并：  

    >cc file1.c file2.o   

    UNIX系统的make命令可自动管理多个文件程序，但是这超出了本书的讨论范围。  
    注意，OS X的Terminal工具可以打开UNIX命令行环境，但是必须先下载命令行编译器(GCC和Clang)。   

2. Linux  
    假定Linux系统安装了GNU C编译器GCC。假设file1.c和file2.c是两个内含C函数的文件，下面的命令将编译两个文件并生成名为a.out的可执行文件：  

    >gcc file1.c file2.c  

    另外，还生成两个名为file1.o和file2.o的目标文件。如果后来改动了file1.c，而file2.c不变，可以使用以下命令编译第1个文件，并与第2个文件的目标代码合并：   

    >gcc file1.c file2.o   


3. DOS命令行编译器  
    绝大多数DOS命令行编译器的工作原理和UNIX的cc命令类似，只不过使用不同的名称而已。其中一个区别是，对象文件的扩展名是.obj，而不是.o。一些编译器生成的不是目标代码文件，而是汇编语言或其他特殊代码的中间文件。  

4. Windows和苹果的IDE编译器  
    Windows和Macintosh系统使用的集成开发环境中的编译器是面向项目的。项目描述的是特定程序使用的资源。资源包括源代码文件。这种IDE中的编译器要创建项目来运行单个文件程序。对于多个文件程序，要使用相应的菜单命令，把源代码文件加入一个项目中。要确保所有的源代码文件都在项目列表中列出。许多IDE都不用在项目列表中列出头文件，因为项目只管理使用的源代码文件，源代码文件中的#include指令管理该文件中使用的头文件。但是，Xcode要在项目中添加头文件。  

5. 使用头文件  
    如果把main()放在第1个文件中，把函数定义放在第2个文件中，那么第1个文件仍然要使用函数原型。把函数原型放在头文件中，就不用在每次使用函数文件时都写出函数的原型。C标准库就是这样做的，例如，把I/O函数原型放在stdio.h中，把数学函数原型放在math.h中。你也可以这样用自定义的函数文件。  
    另外，程序中经常用C预处理定义符号常量。这种定义只储存了那些包含#define指令的文件。如果把程序的一个函数放进一个独立的文件中，你也可以使用#define指令访问每个文件。最直接的方法是在每个文件中再次输入指令，但是这个方法既耗时又容易出错。另外，还会有维护的问题：如果修改了#define定义的值，就必须在每个文件中修改。更好的做法是，把#define指令放进头文件，然后再每个源文件中使用#include指令包含该文件即可。  
    总之，把函数原型和已定义的字符常量放在头文件中是一个良好的编程习惯。我们考虑一个例子：假设要管理4家酒店的客房服务，每家酒店的房价不同，但是每家酒店所有房间的房价相同。对于预定住宿多天的客户，第2天的房费是第1天的95%，第3天使第2天的95%，以此类推。设计一个程序让用户指定酒店和入住天数，然后计算并显示总费用。同时，程序要实现一份菜单，允许用户反复输入数据，除非用户选择退出。  
    程序usehotel.c、hotel.c和hotel.h演示了如何编写这样的程序。第一个程序包含main()函数，提供整个程序的组织结构。第2个程序清单包含支持的函数，我们假设这些函数在独立的文件中。最后，程序清单9.11列出了一个头文件，包含了该该程序所有源文件中使用的自定义符号常量和函数原型。前面介绍过，在UNIX和DOS环境中，#include "hotel.h"指令中的双引号表明被包含的文件位于当前目录中(通常是包含源代码的目录)。如果使用IDE，需要知道如何把头文件合并成一个项目。  
    [usehotel.c](../../c-example/hotel/usehotel.c)  
    [hotel.c](../../c-example/hotel/hotel.c)
    [hotel.h](../../c-example/hotel/hotel.h)  
    该程序中有几处编写得很巧妙。尤其是，menu()和getnights()函数通过测试scanf()的返回值来跳过非数值数据，而且调用scanf("%*s")跳至下一个空白字符。注意，menu()函数中是符合检查非数值输入和超出范围的数据：  

    >while((status = scanf("%d",&code) !=1 || (code < 1 || code >5)))

    以上代码段利用了C语言的两个规则：从左往右对逻辑表达式求值；一旦求职结果为真，立刻停止求值。在该例中，只有在scanf()成功读入一个数值后，才会检查code的值。  

#### 查找地址：&运算符
指针(pointer)是C语言最重要的概念之一，用于储存变量的地址。前面使用scanf()函数中就使用地址作为参数。概括地说，如果主调函数不使用return返回的值，则必须通过地址才能修改主调函数中的值。接下来，窝们将介绍带地址参数的函数。首先介绍一元&运算符的用法。  
一元&运算符给出变量的存储地址。如果pooh是变量名，那么&pooh是变量的地址。可以把地址看作是变量在内存中的位置。假设有下面的语句：  

>pooh = 24;

假设pooh的存储地址是0B76。那么，下面的语句：  

>printf("%d %p\n",pooh,&pooh);

将输出如下内容(%p是输出地址的转换说明):  

>24 0B76  

如下程序使用&运算符查看不同函数中的同名变量分别储存在什么位置。  
[loccheck.c](../../c-example/loccheck.c)  
首先，两个pooh的地址不同，两个bah的地址也不同。因此，和前面介绍的一样，计算机把它们看成4个独立的变量。其次，寒暑调用mikado(pooh)把实际参数(main()中的pooh)的值传递给形式参数(mikado()中的bah)。注意，这种传递只传递了值。涉及的两个变量并未改变。  
强调第二点是因为这并不是所有语言中都成立。例如，在FORTRAN中，子例程会影响主调例程的原始变量。子例程的变量名可能与原始变量不同，但是它们的地址相同。但是，在C语言中不是这样。每个C函数都有自己的变量。这样做更可取，因为这样做可以防止原始变量被被调函数中的副作用意外修改。然而，正如下节所述，这也带来了一些麻烦。  

#### 更改主调函数中的变量
有时需要在一个函数中更改其他函数的变量。例如，普通的排序任务中交换两个变量的值。假设要交换两个变量x和y的值。简单的思路是：  

>x = y;
>y = x;

这完全不起作用，因为执行到第2行时，x的原始值已经被y的原始值替换了。因此，要多写一行代码，储存x的原始值：  

>temp = x;
>x = y;
>y = temp;

上面这三行代码便可实现交换值的功能，可以编写成一个函数并构造一个程序来测试。如下程序，为了清楚地表明变量属于哪个函数，在main()中使用变量x和y，在intercharge()中使用u和v。  
[swap1.c](../../c-example/swap1.c)  
两个变量的值并未交换！我们在interchange()中添加一些打印语句来检查错误。  
[swap2.c](../../c-example/swap2.c)  
看来，interchange()没有问题，它交换了u和v的值。问题出在把结果传回main()时。interchange()是用的变量并不是main()中的变量。因此，交换u和v的值对x和y的值没有影响！是否能用return语句把值传回main()?当然可以，在interchange()的末尾加上下面一行语句：  

>return u;

然后修改main()中的调用：  

>x = interchange(x, y);

这只能改变x的值，而y的值依旧没变。用return语句之能把被调函数中的一个值传回主调寒暑，但是现在要传回两个值。这没问题！不过，要使用指针。  


#### 指针简介
指针？什么是指针？从根本上看，指针是一个值为内存地址的变量(或数据对象)。正如char类型变量的值是字符，int类型变量的值是整数，指针变量的值是地址。在C语言中，指针有许多用法。本章将介绍如何把指针作为函数参数使用，以及为何要这样用。  
假设一个指针变量名是ptr，可以编写如下语句：  

>ptr = &pooh;//把pooh的地址赋给ptr  

对于这条语句，我们说ptr“指向”pooh。ptr和&pooh的区别是ptr是变量，而&pooh是常量。或者，ptr是可修改的左值，而&pooh是右值。还可以把ptr指向别处：  

>ptr = &bah;//把ptr指向bah，而不是pooh  

现在ptr的值是bah的地址。  
要创建指针变量，先要声明指针变量的类型。假设想把ptr声明为储存int类型变量地址的指针，就要使用下面介绍的新运算符。  

1. 间接运算符:* 
假设已知ptr指向bah，如下所示：  

>ptr = &bah;  

然后使用间接运算符*(indirection operator)找出储存在bah中的值，该运算符有时也称为解引用运算符(dereferencing operator)。不要把间接运算符和二元乘法运算符(*)混淆，虽然它们使用的符号相同，但语法功能不同。  

>val = *ptr;//找出ptr指向的值  

语句ptr=&bah;和val=*ptr;放在一起相当于下面的语句:  

>val = bah;  

由此可见，使用地址和间接运算符可以间接完成上面这条语句的功能，这也是“间接运算符”名称的由来。  

2. 声明指针  
已经很熟悉如何声明int类型和其他基本类型的变量，那么如何声明指针变量？你也许认为是这样声明：  

>pointer ptr;//不能这样声明指针  

为什么不能这样声明？因为声明指针变量时必须指定指针所指向变量的类型，因为不同的变量类型占用不同的存储空间，一些指针操作要求知道操作对象的大小。另外，程序必须知道储存在指定地址上的数据类型。long和float可能占用相同的存储空间，但是它们储存数字却大相径庭。下面是一些指针的声明实例示例：   

>int *pi; //pi是指向int类型变量的指针  
>char *pc; //pc是指向char类型变量的指针  
>float *pf, *pg; //pf、pg都是指向float类型变量的指针  

类型说明符表明了指针所指向对象的类型，星号(\*)表明声明的变量是一个指针。int \*pi；声明的意思是pi是一个指针,\*pi是int类型。如下图：  
![声明并使用指针.png](../../images/C-Learning-two/声明并使用指针.png)  
\*pc指向的值(\*pc)是char类型。pc本身是什么类型？我们描述它的类型是“指向char类型的指针”。pc的值是一个地址，在大部分系统内部，该 地址由一个 无符号整数表示。但是，不要把指针认为是整数类型 。一些处理 整数的操作不能用来处理指针，反之亦然。例如，可以把两个整数相乘，但是不能 把两个 指针相乘。所以，指针实际上是一个新类型，不是整数类型。因此，如前所诉 ，ANSI C专门 为指针提供了%p格式的转换说明。  

3. 使用指针在函数间通信  
我们才刚刚接触指针，指针的世界丰富多彩。本节着重介绍如何使用指针解决函数间的通信问题。请看如下程序，该程序在interchange()函数中使用了指针参数。  
[swap3.c](../../c-example/swap3.c)  
首先看函数调用：  

>interchange(&x,&y);

该函数传递的不是x和y的值，而是它们的地址。这意味着出现在interchange()原型和定义中的形式参数u和v将把地址作为它们的值。因此，应把他们声明为指针。由于x和y是整数，所以u和v是指向整数的指针，其声明如下：  

>void interchange(int *u,int *v)  

接下来 ，在函数体中声明了一个交换值时必需的临时变量：  

>int temp;

通过下面的语句把x的值储存在temp中：  

>temp =  *u  

记住 ，u的值是&下，所以u指向x。这意味着用*u即可表示x的值，这正是我们需要的。  
与此类似，把y的值赋给x，要使用下面的语句:  

>*u = *v;   

这条语句相当于：  

>x=y;  

我们需要一个函数交换x和y的值。把x和y的地址传递给函数，我们让interchange()访问这两个地址。使用指针和*运算符，该函数可以访问储存在这些位置的值并改变它们。  
可以省略ANSI-C风格的函数原型中的形参名，如下所示：  

>void interchange(int *,int *);

一般而言，可以把变量相关的两类信息传递给函数。如果这种形式的函数调用，那么传递的是x的值：***function1(x);***  
如果下面形式的函数调用，那么传递的是x的地址：***function2(&x);***   
第1种形式要求函数定义中的形式参数必须是一个与x的类型相同的变量：  

>int function1(int num);   

第2种形式要求函数定义中的形式参数必须是一个指向正确类型的指针：  

>int function2(int  *ptr);  

如果要计算或处理值，那么使用第1种形式的函数调用；如果要在被调函数中改变主调函数的变量，则使用第2种形式的函数调用。我们用过的scanf()函数就是这样。当程序要把一个值读入变量时，调用的是scanf("%d", &num)。scanf()读取一个值，然后把该值储存到指定的地址上。  
对本例而言，指针让interchange()函数通过自己的局部变量改变main()中变量的值。   
熟悉Pascal和Moudula-2的应该看出第1种形式和Pascal的值参数相同，第2种形式和Pascal的变量 参数类似。C++程序员可能认为，既然C和C++都使用指针变量，那么C应该也有引用变量。让他们失望了，C没有引用变量。对BASIC程序员而言，可能很难理解整个程序。  
![变量的名称地址和值.png](../../images/C-Learning-two/变量的名称地址和值.png)  
变量：名称、地址和值  
通过前面的讨论发现 ，变量的名称、地址和变量的值之间的关系密切。我们来进一步分析。  
编写程序时，可以认为变量有两个属性：名称和值。计算机编译和加载程序后，认为变量也有两个属性：地址和值。地址就是变量在计算机内部的名称。    
在许多语言中，地址都归计算机管，对程序员隐藏。然而在C中，可以通过&运算符访问地址，通过*运算符获得地址上的值。例如，&barn表示变量barn的地址，使用变量名即可获得变量的数值。如：printf("%d\n",barn)打印barn的值，使用*运算符即可获得储存在地址上的值。如果pbarn = &barn，那么*pbarn表示的是储存在&barn地址上的值。  
简而言之，普通变量把值作为基本量，把地址作为通过&运算符获得的派生量，而指针变量把地址作为基本量，把值作为通过*运算符获得的派生量。  
虽然打印地址可以满足读者好奇心，但是这并不是&运算符的主要用途。更重要的是使用&、*和指针可以操纵地址和地址上的内容，如swap3.c所示。   

### 10. 数组和指针
本章介绍以下内容  
关健字：static  
运算符：&、*（一元)  
如何创建并初始化数组  
指针、指针和数组的关系  
编写处理数组的函数  
二维数组  

#### 数组
数组由数据类型相同的一系列元素组成。需要使用数组时，通过声明数组告诉编译器数组内含多少元素和这些元素的类型。编译器根据这些信息正确地创建数组。普通变量可以使用的类型，数组元素都可以用。  

```C 
int main(void)
{
    float candy[365]; /* 内含365个float类型元素的数组 */
    char code[12]; /* 内含12个char类型元素的数组 */
    int states[50]; /* 内含50个int类型元素的数组 */
    ...
}
```

方括号([])表明candy、code和states都是数组，方括号中的数字表明数组中的元素个数。  
要访问数组中的元素，通过使用数组下标数(也称为索引)表示数组中的各元素。数组元素的编号从0开始，所以candy[0]表示candy数组的第1个元素，candy[364]表示第365个元素，也就是最后一个元素。  

1. 初始化数组  
数组通常被用来储存程序需要的数据。例如，一个内含12个整数元素的数组可以储存12个月的天数。在这种情况下，在程序一开始就初始化数组比较好。下面介绍初始化数组的方法。  
只储存单个值的变量有时也称为标量变量(scalar variable)，我们已经很熟悉如何初始化这种变量：  

>int fix = 1;
>float flax = PI*2;  

代码中的PI已定义为宏。C使用新的语法来初始化数组，如下所示：  

```C
int main(void)
{
    int powers[8] = {1,2,4,6,8,16,32,64}; /* 从ANSI C开始支持这种初始化 */
    ...
}
```

如上所示，用以逗号分隔的值列表(用花括号括起来)来初始化数组，各值之间用逗号分隔。在逗号和值之间可以使用空格。根据上面的初始化，把1赋给数组的首元素(powers[0])，以此类推(不支持ANSI的编译器会把这种形式的初始化识别为语法错误，在数组声明前加上关健字static可解决此问题)。  
下面的程序演示了一个小程序，打印每个月的天数。  
[day_mon1.c](../../c-example/day_mon1.c)  
这个程序还不够完善，每4年打错一个月份的天数(即，2月份的天数)。该程序用初始化列表初始化days[]，列表(用花括号括起来)中用逗号分隔各值。  
注意该例使用了符号常量MONTHS表示数组大小，这是我们推荐且常用的做法。例如，如果要采用一年13个月的记法，只需要修改#define这行代码即可，不用在程序中查找所有使用过数组大小的地方。  
***注意 使用const声明数组***  
有时需要把数组设置为只读。这样，程序只能从数组中检索值，不能把新值写入数组。要创建只读数组，应该用const声明和初始化数组。因此，程序day_mon1.c中初始化数组应改成:  

>const int days[MONTHS] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

这样修改后，程序在运行过程中就不能修改该数组中的内容。和普通变量一样，应该使用声明来初始化const数据，因为一旦声明为const，便不能再给它赋值。明确了这一点，就可以在后面的例子中使用const了。  
如果初始化数组失败怎么办？如下程序所示：  
[no_data.c](../../c-example/no_data.c)  
使用数组前必须先初始化它。与普通变量类似，在使用数组元素之前，必须先给它们赋初值。编译器使用的值是内存相应位置上的现有值，因此，读者运行该程序后的输出会与该示例不同。  
***注意 存储类别警告***  
数组和其他变量类似，可以把数组创建成不同的存储类别(storage class)。本章描述的数组属于自动存储类别，意思是这些数组在函数内部声明，且声明时未使用关健字static。到目前为止，本书所用的变量和数组都是自动存储类别。  
在这里提到存储类别的原因是，不同的存储类别有不同的属性，所以不能把本章的内容推广到其他存储类别。对于一些其他存储类别的变量和数组，如果在声明时未初始化，编译器会自动把它们的值设置为0。  
初始化列表中的项数应与数组的大小一致。如果不一致会怎样？如下所示：  
[somedata.c](../../c-example/somedata.c)  
当初始化列表中的值少于数组元素个数时，编译器会把剩余的元素都初始化为0。也就是说，如果不初始化数组，数组元素和未初始化的普通变量一样，其中储存的都是垃圾值;但是，如果部分初始化数组，剩余的元素就会被初始化为0。  
如果初始化列表的项数多于数组元素个数，编译器可没那么仁慈，它会毫不留情地将其视为错误。其实，可以省略方括号中的数字，让编译器自动匹配数组大小和初始化列表中的项数。  
[day_mon2.c](../../c-example/day_mon2.c)

2. 指定初始化器(C99)  
    C99增加了一个新特性：指定初始化器(designated initializer)。利用该特性可以 初始化指定的数组元素。例如，只初始化数组中的最后一个元素。对于传统的C初始化语法，必须初始化最后一个元素之前的所有元素，才能初始化它：  

    >int arr[6] = {0,0,0,0,0,212};   

    而C99规定，可以在初始化列表中使用带方括号的下标指明待初始化的元素：  

    >int arr[6]  =  {[5]=212};  

    对于一般的初始化，在初始化一个元素后，未初始化的元素都会被设置为0。如下程序:  
    [designate.c](../../c-example/designate.c)   
    以上输出揭示了指定初始化器的两个重要特性。第一，如果指定初始化器后面有更多的值，如该例中的的片段：[4] = 31,30,31,那么后面这些值将被用于初始化指定元素后面的元素。也就是说，在days[4]被初始化为31后，days[5]和days[6]将分别被初始化为30和31。第二，如果再次初始化指定的元素，那么最后的初始化将会取代之前的初始化。例如程序中，初始化列表开始时把days[1]初始化为28，但是days[1]又被后面的指定初始化[1]=29初始化为29。  
    如果未指定元素大小会怎样？  

    >int stuff[] = {1,[6] = 23};  
    >int staff[] = {1,[6] = 4,9,10};  

    编译器会把数组的大小设置为足够装得下初始化的值。所以，stuff数组有7个元素，编号为0~6;而staff数组的元素比stuff数组多两个(即有9个元素)。  

3. 给数组元素赋值  
    声明数组后，可以借助数组下标(或索引)给数组元素赋值。例如 ，下面的程序给数组的所有元素赋值：  

    ```C
    #include <stdio.h>
    #define SIZE 50
    int main(void)
    {
        int counter,evens[SIZE];
        for(counter = 0;counter < SIZE; counter++)
            evens[counter] = 2 * counter；
        ...
    }
    ```

    注意这段代码中使用循环给数组的元素依次赋值。C不允许把数组作为一个单元赋给另一个数组 ，除初始化外也不允许使用花括号列表的形式赋值。如下：  

    ```C
    #define SIZE 5
    int  main(void)
    {
        int oxen[SIZE] = {5,3,2,8}; //初始化没问题
        int yaks[SIZE];
        yaks = oxen;  //不允许
        yaks[SIZE] = oxen[SIZE]; //数组下标越界
        yaks[SIZE] = {5,3,2,8};
    }
    ```

    oxen数组的最后一个元素是oxen[SIZE-1]，所以oxen[SIZE]和yaks[SIZE]都超出了两个数组的末尾。  
    
4. 数组边界  
    在使用数组时，要防止数组下标超出边界。也就是说，必须确保下标是有效的值。例如，假设有下面的声明：  

    >int doofi[20];  

    那么在使用该数组时，要确保程序中使用的数组下标在0~19的范围内，因为编译器不会检查出这种错误。  
    考虑程序bounds.c的问题。该程序创建了一个内含4个元素的数组，然后错误地使用了-1~6的下标。  
    [bounds.c](../../c-example/bounds.c)  
    编译器不会检查数组下标是否使用得当。在C标准中，使用越界下标的结果是未定义的。这意味着程序看上去可以运行，但是运行结果很奇怪，或异常中止。
    编译器似乎把value2储存在数组的前一个位置，把value1储存在数组的后一个位置(其他编译器在内存中储存数据的顺序可能不同)。在上面的输出中，arr[-1]与value2对应的内存地址相同，arr[4]和value1对应的内存地址相同。因此，使用越界的数组下标会导致程序改变其他变量的值。不同的编译器运行该程序的结果可能不同，有些会导致程序异常中止。  
    C语言为何会允许这种麻烦事发生？这要归功于C信任程序员的原则。不检查边界，C程序可以运行更快。编译器没必要捕获所有的下标错误，因为在程序运行之前，数组的下标值可能尚未确定。因此，为安全起见，编译器必须在运行时添加额外代码检查数组的每个下标值，这会降低程序的运行速度。C相信程序员能编写正确的代码，这样的程序运行速度更快。  
    还要记住一点：数组元素的编号从0开始。最好是在声明数组时使用符号常量来表示数组的大小。这样做能确保整个程序中的数组大小始终一致。  

5. 指定数组的大小  
    之前的程序示例都使用整型常量来声明数组：  
    在C99标准之前，声明数组时只能在方括号中使用整型常量表达式。所谓整型常量表达式，是由整形常量构成的表达式。sizeof表达式被视为整型常量，但是const值不是。另外，表达式的值必须大于0：  

    >int n = 5;
    >int m = 8;
    >float a1[5];  //可以
    >float a2[5*2 + 1]; //可以
    >float a3[sizeof(int)+1] //可以
    >float a4[-4];  //不可以，数组大小必须大于0
    >float a5[0];   //不可以，数组大小必须大于0
    >float a6[2.5]; //不可以，数组大小必须是整数
    >float a7[(int)2.5];    //可以，已被强制转换为整型常量
    >float a8[n];   //C99之前不允许
    >float a9[m];   //C99之前不允许

    以前支持C90标准的编译器不允许后两种声明方式。而C99标准允许这样声明，这创建了一种新型数组，称为变长数组(variable-length array)或简称VLA(C11放弃了这一创新的举措，把VLA设定为可选，而不是语言必备的特性)。  

#### 多维数组
数组的数组，主数组(master array)有5个元素(每个元素表示一年),每个元素是内含12个元素的数组。声明如下:  

>float rain[5][12];  

rain的首元素rain[0]是一个内含12个float类型值的数组。所以，rain[1]、rain[2]等也是如此。如果，rain[0]是一个数组，那么它的首元素就是rain[0][0],第二个元素是rain[0][1]，以次类推。简而言之，数组rain有5个元素，每个元素都是内含12个float类型元素的数组，rain[0]是内含12个float值的数组，rain[0][0]是一个float类型的值。假设要访问位于2行3列的值，则使用rain[2][3]。  
![二维数组.png](../../images/C-Learning-two/二维数组.png)  
该二维视图有助于帮助理解，在计算机内部，这样的数组是按顺序存储的，从第1个内含12个元素的数组开始，然后是第2个内含12个元素的数组，以此类推。  
我们要在气象分析程序中用到这个二维数组。该程序的目标是，计算每年的总降水量、年平均降水量和月平均降水量。要计算年总降水量，必须对一行数据求和；要计算某月份的平均降水量，必须对一列数据求和。二维数组很直观，实现这些操作也很容易。如下:  
[rain.c](../../c-example/rain.c)  

1. 初始化二维数组  
    初始化二维数组是建立在初始化一维数组的基础上。首先，初始化一维数组如下:  

    >sometype ar1[5] = {val1,val2,val3,val4,val5};  

    这里，val1、val2等表示sometype类型的值。例如，如果sometype是int，那么val1可能是7；如果sometype是double，那么val1可能是11.34，诸如此类。但是rain是一个内含5个元素的数组，每个元素又是内含12个float类型元素的数组。所以，对rain而言，val1应该包含12个值，用于初始化内含12个float类型元素的一维数组。  
    也就是说，如果sometype是一个内含12个double类型元素的数组，那么val1就是一个由12个double类型值构成的数值列表。因此，为了初始化二维数组rain，要用逗号分隔5个这样的数值列表。  
    初始化时也可省略内部的花括号，只保留最外面的一对花括号。只要保证初始化的数值个数正确，初始化的效果与上面相同。但是如果初始化的数值不够，则按照先后顺序逐行初始化，直到用完所有的值。后面没有值初始化的元素被统一初始化为0。  
    因为储存在数组rain中的数据不能修改，所以程序使用了const关键字声明该数组。  

2. 其他多维数组  
    二维数组的相关内容都适用于三维数组或更多维的数组。可以这样声明一个三维数组:  

    >int box[10][20][30];  

    可以把一维数组想象成一行数据，把二维数据想象成数据表，把三维数组想象成一叠数据表。  
    
#### 指针和数组
数组名是数组首元素的地址。也就是说，如果flizny是一个数组，下面的语句成立:  

``` C
flizny == &flizny[0];   //数组名是该数组首元素的地址  
```

flizny和&flizny[0]都表示数组首元素的内存地址(&是地址运算符)。两者都是常量，在程序的运行过程中，不会改变。但是，可以把他们赋值给指针变量，然后可以修改指针变量的值，如下程序所示：  
[pnt_add.c](../../c-example/pnt_add.c)  
系统中，地址按字节编址，short类型占用2字节，double类型占用8字节。在C中，指针加1指的是增加一个存储单元。对数组而言，这意味着把加1后的地址是下一个元素的地址，而不是下一个字节的地址。这是声明指针所指向对象类型的原因之一。只知道地址不够，因为计算机要知道储存对象需要多少字节(即使指针指向的是标量变，也要知道变量的类型，否则*pt就无法正确地取回地址上的值）。  
在指针前面使用\* 运算符可以得到该指针所指向对象的值。  
指针加1，指针的值传递增它所指向类型的大小。  
下面的等式体现了C语言的灵活性:  
```C
dates + 2 == &date[2];  //相同地址  
*(date + 2) == dates[2]; //相同的值
```

以上关系表明了数组和指针的关系十分密切，可以使用指针标识数组的元素和获得元素的值。从本质上看，同一个对象有两种表示法。实际上，C语言标准在描述数组表示法时确实借助了指针。也就是说，定义ar[n]的意思是*(ar+n)。可以认为*(ar+n)的意思是“到内存的ar位置，然后移动n个单元，检索储存在那里的值”。  
不能混淆*(dates+2)和*dates+2。间接运算符(*)的优先级高于+。  

#### 函数、数组和指针

1. 使用指针形参  
函数要处理数组必须知道何时开始、何时结束。sum()函数使用一个指针形参标识数组的开始，用一个整数形参表明待处理数组的元素个数(指针形参也表明了数组中的数据类型)。但是这并不是给函数传递必备信息的唯一方法。还有一种方法是传递两个指针，第1个指针指明数组的开始处，第2个指针指明数组的结束处。如下程序演示了这种方法：  
[sum_arr2.c](../../c-example/sum_arr2.c)  

2. 指针表示法和数组表示法  
处理数组的函数实际上用指针作为参数，但是在编写这样的函数时，可以选择是使用数组表示法还是指针表示法。使用数组表示法，让函数是处理数组的这一意图更加明显。另外，许多其他语言的程序员对数组表示法更熟悉，如FORTRAN、Pascal、Modula-2或BASIC。其他程序员可能更习惯使用指针表示法，觉得使用指针更自然。  
至于C语言，ar[i]和*(ar+i)这两个表达式都是等价的。无论ar是数组名还是指针变量，这两个表达式都没问题。但是，只有当ar是指针变量时，才能使用ar++这样的表达式。  
指针表示法(尤其与递增运算符一起使用时)更接近机器语言，因此一些编译器在编译时能生成效率更高的代码。   

#### 指针操作
C提供了一些基本的指针操作，下面的程序中演示了8种不同的操作。另外还可以使用关系运算符来比较指针。  
[ptr_ops.c](../../c-example/ptr_ops.c)  
指针变量的基本操作如下:  
+ 赋值：把地址赋给指针。如数组名、带地址运算符(&)的变量名、另一个指针。  
+ 解引用：\*运算符给出指针指向地址上储存的值。因此，\*ptr1的初值是100，该值储存在ptr1对应的地址上。  
+ 取址：和所有变量一样，指针变量也有自己的地址和值。对指针而言，&运算符给出指针本身的地址。
+ 指针和整数相加：可以使用+运算符把指针与整数相加，或整数与指针相加。无论哪种情况，整数都会和指针所指向类型的大小相乘，然后把结果与初始地址相加。  
+ 递增指针：递增指向数组元素的指针可以让该指针移动至数组的下一个元素。  
+ 指针减去一个整数：可以使用-运算符从一个指针中减去一个整数。指针必须是第一个运算对象，整数是第2个运算对象。  
+ 递减指针：对应递增指针。  
+ 指针求差：可以计算两个指针的差值。通常，求差的两个指针分别指向同一个数组的不同元素，通过计算求出两元素之间的距离。差值的单位与数组类型的单位相同。如果指向两个不同数组的指针进行求差运算可能会得出一个值，或者导致运行时错误。  
+ 比较：使用关系运算符可以比较两个指针的值，前提是两个指针都指向相同类型的对象。  
在递增或递减指针时还要注意一些问题。编译器不会检查指针是否仍指向数组元素。C只能保证指向数组任意元素的指针和指向数组后面第1个位置的指针有效。  
不能解引用未初始化的指针  

>int *pt;//未初始化的指针  
>*pt = 5; //严重的错误  

因为pt为被初始化，其值是一个随机值，所以不知道5将储存在何处。这可能不会出错，也可能会擦写数据或代码，或者导致程序崩溃。创建一个指针时，系统只分配了储存指针本身的内存，并未分配储存数据的内存。因此，在使用指针之前，必须先用已分配的地址初始化它。  

#### 保护数组中的数据
编写一个处理基本类型(int)的函数是，要选择是传递int类型的值还是传递指向int的指针。通常都是直接传递数值，只有程序需要在函数中改变该数值时，才会传递指针。对于数组别无选择，必须传递指针，因为这样做效率高。如果一个函数按值传递数组，则必须分配足够的空间来储存原数组的副本，然后把原数组所有的数据拷贝至新的数组中。如果把数组的地址传递给函数，让函数直接处理原数组则效率要高。  
然而，有些时候某些函数并不需要修改数据。例如，下面的函数计算数组中所有元素之和，它不用改变数组的数据。但是，由于ar实际上是一个指针，所以编程错误可能会破坏原始数据。

1. 对形式参数使用const  
ANSI C提供了一种预防手段。如果函数的意图不是修改数组中的数据内容，那么在函数原型和函数定义中声明形式参数时应使用关键字const。例如，sum()函数的原型和定义如下:  

```C
int sum(const int ar[],int n);
int sum(const int ar[],int n)
{
    int i;
    int total = 0;
    for(i = 0; i < n; i++)
    total += ar[i];
    return total;
}
```

以上代码中的const告诉编译器，该函数不能修改ar指向的数组中的内容。如果在函数中不小心使用类似ar[i]++的表达式，编译器会捕获这个错误，并生成一条错误信息。  

2. const的其他内容  

之前使用const创建过变量:  

>const double PI = 3.1415926;  

虽然用#define指令可以创建类似功能的符号常量，但是const的用法更加灵活。可以创建const数组、const指针和指向const的指针。  
指向const的指针不能用于改变值。如下：  

>double rates[5] = {88.99,100.12,59.45,183.11,340.5};
>const double *pd = rates;
>*pd = 29.89; //不允许
>pd[2] = 222.22; //不允许
>rates[0] = 99.99; //允许，因为rates未被const限定

第二行代码把pd指向的double类型的值声明为const，这表明不能使用pd来改变它所指向的值:
无论是使用指针表示法还是数组表示法，都不允许使用pd修改它所指向数据的值。但是要注意，因为rates并未被声明为const，所以仍然可以通过rates修改元素的值。另外，可以让pd指向别处。  
关于指针赋值和const需要注意一些规则。首先，把const数据或非const数据的地址初始化为指向const的指针或为其赋值是合法的，然而只能把非const数据的地址赋给普通指针。  
const还有其他的用法。如，可以声明并初始化一个不能指向别处的指针，关键是const的位置。最后，在创建指针时还可以使用const两次，该指针既不能更改它所指向的地址，也不能修改指向地址上的值。  

>double rates[5] = {88.99, 100.12, 59.45, 183.11,340.5};
>double *const pc = rates;
>const double *const pc1 = rates;
>pc = &rates[2];  //不允许，因为该指针不能指向别处
>*pc = 92.99;  //没问题，因为rates数组没有const
>pc1 = &rates[2];  //不允许
>*pc = 92.99;  //不允许

#### 指针和多维数组

假设有下面的声明：  

>int zippo[4][2];  

数组名zippo是该数组首元素的地址。对于上面的声明来说，zippo的首元素是一个内含两个int值的数组，所以zippo是这个内含两个int值的数组的地址。  
因为zippo是数组首元素的地址，所以zippo的值和&zippo[0]的值相同。而zippo[0]本身是一个内含两个整数的数组，所以zippo[0]的值和它首元素(一个整数)的地址(&zippo[0][0])相同。简而言之，zippo[0]是一个占用int大小对象的地址，而zippo是一个占用两个int大小对象的地址。由于这个整数和内含两个整数的数组都开始于同一个地址，所以zippo和zippo[0]的值相同。  
所以给指针或地址加1，其值会增加对应类型大小的数值。  
解引用一个指针(在指针前使用\*运算符)或在数组名后使用带下标的[]运算符，得到引用对象代表的值。因为zippo[0]是该数组首元素(zippo[0][0])的地址，所以\*(zippo[0])表示储存在zippo[0][0]上的值。与此类似，\*zippo代表该数组首元素(zippo[0])的值，但是zippo[0]本身是一个int类型值的地址。该值的地址是&zippo[0][0]，所以\*zippo就是&zippo[0][0]。所以再次进行解引用\*\*zippo与\*&zippo[0][0]等价，表示zippo[0][0]，这个int类型的值。

1. 指向多维数组的指针  
    如何声明一个指针变量pz指向一个二维数组(如，zippo)。在编写处理类似zippo这样的二维数组时会用到这样的指针。把指针声明为指向int的类型还不够。因为指向int只能与zippo[0]的类型匹配，说明该指针指向一个int类型的值。但是zippo是它首元素的地址，该元素是一个内含两个int类型值的一维数组。因此，pz必须指向一个内含两个int类型值的数组，而不是指向一个int类型值，其声明如下:  

    >int (*px)[2];  //pz指向一个内含两个int类型值的数组  

    以上代码把pz声明为指向一个数组的指针，该数组内含两个int类型值。为什么要在声明中使用圆括号？因为[]的优先级高于\*。  

    >int * pax[2];  //pax是一个内含两个指针元素的数组，每个元素都指向int的指针  

    由于[]优先级高，先于pax结合，所以pax成为一个内含两个元素的数组。然后\*表示pax数组内含两个指针。最后，int表示pax数组中的指针都指向int类型的值。因此，这行代码声明了两个指向int的指针。而前面有圆括号的版本，\*先与pz结合，因此声明的是一个指向数组(内含两个int类型的值)的指针。  
    [zippo2.c](../../c-example/zippo2.c)  

2. 指针的兼容性  
    指针之间的赋值比数值类型之间的赋值要严格。例如，不用类型转换就可以把int类型的值赋给double类型的变量，但是两个类型的指针不能这样做。  
    对于一个指向指针的指针(int \*\*px)和指向数组的指针(int (\*ar)[2])。两者的类型不同，不能把ar赋值给px。但是，*px和ar[0]都是指向int的指针，因此可以互相赋值。  
3. 函数和多维数组  
    如果要编写处理二维数组的函数，首先要能正确地理解指针才能写出声明函数的形参。在函数体中，通常使用数组表示法进行相关操作。  

    下面是一个处理二维数组的函数。一种方法是，利用for循环把处理一维数组的函数应用到二维数组的每一行。  

    ```C  
    int junk[3][4] = { {2,4,5,8}, {3,5,6,9}, {12,10,8,6} };
    int i,j;
    int total = 0;
    for( i = 0; i < 3; i++)
      total += sum(junk[i],4);
    ```

    如果junk是二维数组，junk[i]就是一维数组，可将其视为二维数组的一行，这里，sum()函数计算二维数组的每行的总和，然后for循环再把每行的总和加起来。  
    然而，这种方法无法记录行和列的信息。用这种方法计算总和，行和列的信息并不重要。但如果每行代表一年，每列代表一个月，就还需要一个函数计算某列的总和。该函数要知道行和列的信息，可以通过声明正确类型的形参变量来完成，以便函数能正确地传递数组。在这种情况下，数组junk是一个内含3个数组元素地数组，每个元素是内含4个int类型值地数组。通过前面地讨论可知，这表明junk是一个指向数组(内含4个int类型值)地指针。可以这样声明函数的形参:  

    >void somefunction(int (*pt)[4]);

    另外，如果当且仅当pt是一个函数的形式参数时，可以这样声明  

    >void somefunction(int pt[][4]);

#### 变长数组

#### 复合字面量
