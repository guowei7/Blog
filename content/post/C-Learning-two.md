---
title: "C Learning Two"
date: 2020-12-12T19:05:35+08:00
Description: "C primer Plus继续学习"
Tags: ["C"]
Categories: ["编程语言"]
DisableComments: false
---

由于C-Learning.md存在损坏，故重开一篇继续记录  
<!--more-->
### 7. C控制语句：分支和跳转  
本章介绍以下内容：  
关键字：if、else、switch、continue、break、case、default、goto  
运算符：&&、||、？ ：   
函数：getchar()、putchar()、ctype.h系列  
如何使用if和if else语句，如何嵌套它们   
在更复杂的测试表达式中用逻辑运算符组合关系表达式  
C的条件运算符  
switch语句  
break、continue和goto语句    
使用C的字符I/O函数：getchar()和puchar()  
ctype.h头文件提供的字符分析函数系列  

#### if语句  
下面的程序是读取一系列数据，每个数据都表示每日的最低问题，然后打印统计的总天数和最低温度在0°以下的天数占总天数的百分比。程序中的循环通过scanf()读入温度值。while循环每迭代一次，就递增计数器增加天数，其中的if语句负责判断0°以下的温度并单独统计相应的天数。  
[colddays.c](../../c-example/colddays.c)  
为避免整数除法，该程序示例把计算后的百分比强制转换为float类型。其实，也不必使用强制类型转换，因为在表达式100.0  * cold_dyas / all_days中，将首先对表达式100.0 * cold_days求值，由于C的自动转换类型规则，乘积会被强制转换成浮点数。但是，使用强制类型转换可以明确表达式转换类型的意图，保护程序免受不同版本编译器的影响。if语句被称为分支语句(branching statement)或选择语句(selection statement)，因为它相当于一个交叉点，程序要在两条分支中选择一条执行。if语句的通用形式如下：  

>if(expression)  
>statement  

如果对expression求值为真(非0),则执行statement：否则，跳过statement。与while循环一样，statement可以是一条简单语句或复合语句。if语句的结构和while语句很相似，它们的主要区别是：如果满足条件执行的话，if语句 只能测试和执行一次，而while语句可以测试和执行多次。  
通常，expression是关系表达式，即比较两个量的大小(如，表达式x > y或c == 6)。如果expression为真(即x大于y，或c == 6),则执行statement。否则，忽略statement。概括地说，可以使用任意表达式，表达式的值为0则为假。  
statement部分可以是一条简单语句，如本例所示，或者是一条用花括号括起来的复合语句(或块)  
注意，即使if语句由复合语句构成，整个if语句仍被视为一条语句。  

#### if else语句   
简单形式的if语句可以让程序选择执行一条语句，或者跳过这条语句。C还提供了if else形式，可以在两条语句之间作选择。  
注意，if else语句的通用形式是：  

>if(expression)
>statement1
>else
>statement2

如果expression为真(非0),则执行statement1；如果expression为假或0，则执行else后面的statement2。statement1和statement2可以是一条简单语句或复合语句。C并不要求一定要缩进，但这是标准风格。缩进让根据测试条件的求值结果来判断执行哪部分语句一目了然。  
如果要在if和else之间执行多条语句，必须用花括号把这些语句括起来成为一个块。   

+ 介绍getchar()和putchar()  
    getchar()函数不带任何参数，它从输入队列中返回下一个字符。例如，下面的语句读取下一个字符输入，并把该字符的值赋给变量ch：  
    ``` C
    ch = getchar();
    ```
    该语句与下面的语句效果相同：  
    ``` C
    scanf("%c",&ch);
    ```
    putchar函数打印它的参数。例如，下面的语句把之前赋给ch的值作为字符打印出来：  
    ``` C
    putchar(ch);
    ```
    该语句与下面的语句效果相同：  
    ``` C
    printf("%c",ch);
    ```
    由于这些函数只处理字符，所以它们比更通用的scanf()和printf()函数更快、更简洁。而且，注意getchar()和putchar()不需要转换说明，因为它们只处理字符。这两个函数通常定义在stdio.h头文件中(而且，他们通常是预处理宏，而不是真正的函数，第16章会讨论类似函数的宏)。  
    接下来，我们编写一个程序来说明这两个函数是如何工作的。该程序把一行输入重新打印出来，但是每个非空格都被替换成原字符在ASCII序列中的下一个字符，空格不变。这一过程可描述为"如果字符是空白，原样打印；否则，打印原字符在ASCII序列中的下一个字符"。   
    [cypher1.c](../../c-example/cypher1.c)  
+ ctype.h系列的字符函数  
    C有一系列专门处理字符的函数，ctype.h头文件包含了这些函数的原型。这些函数接受一个字符作为参数，如果该字符属于某特殊的类别，就返回一个非零值；否则，返回0。例如，如果isalpha()函数的参数是一个字母，则返回一个非零值。如下：
    [cypher2.c](../../c-example/cypher2.c)  
    
+ 多重选择else if  
    现实生活中我们经常有多种选择。在程序中也可以用else if扩展if else结构模拟这种情况。  
+ else与if配对  
    如果程序中有许多if和else，编译器如何知道哪个if对应哪个else？   
    规则是，如果没有花括号，else与离它最近的if匹配，除非最近的if被花括号括起来。
+ 多层嵌套的if语句  
    前面介绍的if...else if...else序列是嵌套if的一种形式，从一系列选项中选择一个执行。有时，选择一个特定选项后又引出其他选择，这种情况可以使用另一种嵌套if。例如，程序可以使用if else选择男女，if else的每个分支里又包含另一个if else来区分不同收入的群体。   
    我们把这种形式的嵌套if应用在下面的程序中。给定一个整数，显示所有能整除它的约数。如果没有约数，则报告该数是一个素数。  
    在编写程序的代码之前要规划好。首先，要总体设计一下程序。

    1.  为方便起见，程序应该使用一个循环让用户能连续输入待测试的数。这样，测试一个新的数字时不必每次都要重新运行程序。  
    2.  下一步，设计如何找出约数。最直接的方法是：  
    ``` C
    for(div = 2; div < num; div++)
        if(num % div == 0)
            printf("%d is divisible by %d\n",num,div);
    ```
    3. 该循环检查2~num之间的所有数字，测试它们是否能被num整除。但是，这个方法有点浪费时间。可以改进一下，分析后发现，必须测试的书只要到num的平方根就可以了，不用到num。对于9这样的数字，不会节约很多时间，但是对于10000这样的数，使用哪一种方法求约数差别很大。不过，我们不用在程序中计算平方根，可以这样写测试条件：  
    ``` C
    for(div = 2; (div * div) <= num;div++)
        if(num % div == 0)
            printf("%d is divisible by %d and %d.\n",num,div,num/div);
    ```
    不使用平方根而用这样的测试条件，有两个原因。其一，整数乘法比求平方根快。其二，我们还没有正式介绍平方根函数。  
    4. 还有两个问题需要解决。第一个问题，如果待测试的数是一个完全平方数怎么办？报告144可以被12和12整除显得有点傻。可以使用嵌套if语句测试div是否等于num/div。如果是，程序只打印一个约数。第二个问题，如何知道一个数字是素数？如果num是素数，程序流不会进入if语句。要解决这个问题，可以在外层循环把一个变量设置为某个值，然后在if语句中把该变量重新设置为0.循环完成后，检查该变量是否是1，如果是，说明没有进入if语句，那么该数就是素数。这样的变量通常称为标记(flag)。  
    [divisors.c](../../c-example/divisors.c)  

#### 逻辑运算符  
读者已经很熟悉了，if语句和while语句通常使用关系表达式作为测试条件。有时，把多个关系表达式组合起来会很有用。例如，要编写一个程序，计算输入的一行句子中除单引号和双引号以外其他字符的数量。这种情况下可以使用逻辑运算符，并使用句点(.)标识句子的末尾。   
[chcount.c](../../c-example/chcount.c)  

1. 备选拼写：iso646.h头文件  
    C是在美国用标准美式键盘开发的语言。但是在世界各地，并非所有的键盘都有和美式键盘一样的符号。因此，C99标准新增了可代替逻辑运算符的拼写，它们被定义在iso646.h头文件中。如果在程序中包含该头文件，便可用and代替&&、or代替||、not代替！。  
2. 优先级  
    !运算符的优先级很高，比乘法运算符还高，与递增运算符的优先级相同，只比圆括号的优先级低。&&运算符的优先级比||运算符高，但是两者的优先级都比关系运算符低，比赋值运算符高。  
3. 求值顺序  
    除了两个运算符共享一个运算对象的情况外，C通常不保证先对复杂表达式中哪部分求值。例如，下面的语句，可能先对表达式5 + 3求值，也可能先对表达式9 + 6求值：  
    
    >apples = (5+3) * (9+5)  

    C把先计算哪部分的决定权留给编译器的设计者，以便针对特定系统优化设计。但是，对于逻辑运算符是个例外，C保证逻辑表达式的求值顺序是从左往右。&&和||运算符都是序列点，所以程序在从一个运算对象执行到下一个运算对象之前，所有的副作用都会生效。而且，C保证一旦发现某个元素让整个表达式无效，便立即停止求值。
4. 范围  
    &&运算符可用于测试范围。例如，要测试score是否在90~100的范围内，可以这样写：  
    ``` C
    if(range >= 90 && range <=  100)
        printf("Good show!\n");
    ```
    千万不要模仿数学上的写法：  
    ``` C
    if(90 <= range <=100)
        printf("Good show!\n");
    ```
    这样写的问题是代码有语义错误，而不是语法错误，所以编译器不会捕获这样的问题。由于<=运算分手的求值顺序是从左往右，所以编译器把测试表达式解释为：  
    (90 <= range) <= 100
    子表达式90 <= range的值要么是1，要么是0。这两个值都小于100，所以不管range的值是多少，整个表达式都恒为真。因此，在范围测试中要使用&&。  
    许多代码都用范围测试来确定一个字符是否小写字母。例如，假设ch是char类型的变量：  
    ``` C
    if(ch >= 'a'&&ch <= 'z')
        printf("That's a lowercase character.\n");
    ```
    该方法仅对于像ASCII这样的字符编码有效，这些编码中相邻字母与相邻数字一一对应。但是，对于像EBCDIC这样的代码就没有了。相应的可移植方法是，用ctype.h系列中的islower()函数：  
    ``` C
    if(islower(ch))
        printf("That's a lowercase character.\n");
    ```
    无论使用哪种特定的字符编码，islower()函数都能正常运行。   

#### 一个统计单词的程序  
现在，我们可以编写一个统计单词数量的程序(即，该程序读取并报告单词的数量)。该程序还可以计算字符数和行数。先来看看编写这样的程序要涉及那些内容。  
首先，该程序要逐个字符读取输入，知道何时停止读取。然后，该程序能识别并计算这些内容：字符、行数和单词。  
[wordcnt.c](../../c-example/wordcnt.c)  

#### 条件运算符： ？ ：  
C提供条件表达式(conditional expression)作为表达式if else语句的一种便捷方式 ，该 表达式使用? :条件运算符。该运算符分为两部分，需要3个运算对象。  
条件表达式的通用形式如下：  
>expression1 ? expression2 : expression3   

#### 循环辅助:continue和break  
一般而言，程序进入循环后，在下一次循环测试之前会执行完循环体中的所有语句。continue和break语句可以根据循环体中的测试结果来忽略一部分循环内容，甚至结束循环。  

1. continue语句  
    3种循环都可以使用continue语句。执行到该语句时，会跳过本次迭代的剩余部分，并开始下一轮迭代。如果continue语句在嵌套循环内，则只会影响包含该语句的内层循环。  
    从何处开始继续循环？对于while和do while循环，执行continue语句后的下一个行为是对循环的测试表达式求值。对于for循环，执行continue后的下一个行为是对更新表达式求值，然后是对循环测试表达式求值。  
2. break语句  
    程序执行到循环中的break语句时，会终止包含它的循环，并继续执行下一阶段。  
    break还可用于因其他原因退出循环的情况。  
    在for循环中的break和continue的情况不同，执行完break语句后会直接执行循环后面的第1条语句，连更新部分也跳过。嵌套循环内层的break只会让程序跳出包含它的当前循环，要跳出外层循环还需要一个break；  

#### 多重选择：switch和breaak  
使用条件运算符和if else语句很容易编写二选一的程序。然而，有时程序需要在多个选项中进行选择。可以用if else if...else来完成。但是，大多数情况下使用switch语句更方便。  

1. switch语句  
    要对紧跟在关键字switch后圆括号中的表达式求值。然后程序扫描标签列表，直到发现一个匹配的值为止。然后程序跳转至那一行。如果没有匹配的标签怎么办？如果有default:标签行，就跳转至该行；否则程序继续执行在switch后面的语句。  
    break语句在其中起什么作用？它让程序离开switch语句，跳至switch语句后面的下一条语句。如果没有break语句，就会从匹配标签开始执行到switch末尾。  
    switch在圆括号中的测试表达式的值应该是一个整数值(包括char类型)。case标签必须是整数类型的常量或整型常量表达式。不能用变量作为case标签。  

2. 只读每行的首字符  
    这种丢弃一行中其他字符的行为，经常出现在响应单字符的交互程序中。可以用下面的代码实现这样的行为：  
    ``` C 
    while(getchar()!='\n')
        continue;
    ```
    循环从输入中读取字符，包含按下Enter键产生的换行符。注意，函数的返回值并没有赋给ch，以上代码所做的只是读取并丢弃字符。由于最后丢弃的字符是换行符，所所以下一个被读取的字符是下一行的首字母。在外层的while循环中，getchar()读取首字母并赋给ch。  
3. 多重标签  
    如下程序所示，可以在switch语句中使用多重case标签。  
    [vowels.c](../../c-example/vowels.c)  
4. switch和if else  
    何时使用switch？何时使用if else？你经常会别无选择。如果根据浮点类型的变量或表达式来选择，就无法使用switch。如果根据变量在某范围内决定程序流的去向，使用switch就很麻烦，这种情况使用if就很方便。
 
#### goto语句  
早期版本的BASIC和FORTRAN所依赖的goto语句，在C中仍然可用。但是C和其他两种语言不同，没有goto语句C程序也能运行良好。  
goto语句有两部分：goto和标签名。标签的命令遵循变量命名规则，如下所示：

>goto part2;

要让这条语句正常工作，函数还必须包含另一条标为part2的语句，该语句一标签名后紧跟一个冒号开始：  

>part2:printf("Refined analysis:\n");

1. 避免使用goto  
    原则上，根本不用在C程序中使用goto语句。但是，如果你曾经学过FORTRAN或BASIC，可能还会依赖用goto来编程。  
    但是C程序员可以接受一种goto的用法，出现问题时从一组嵌套循环中跳出(一条break语句只能跳出当前循环)

### 字符输入/输出和输入验证  
本章介绍以下内容：  
更详细地介绍输入、输出以及缓冲输入和无缓冲输入的区别  
如何通过键盘模拟文件结尾条件  
如何使用重定向把程序和文件相连接  
创建更友好的用户界面  
#### 单字符I/O：getchar()和puchar  
之前提到过，getchar()和puchar()每次只处理一个字符。你可能认为这种方法实在太笨拙了，毕竟与我们的阅读方式相差甚远。但是，这种方法很适合计算机。而且，这是绝大多数文本(即，普通文字)处理程序所用的核心方法。如下程序，获取从键盘输入的字符，并把这些字符发送到屏幕上。程序使用while循环，当读到#字符时停止。  
[echo.c](../../c-example/echo.c)  
为何输入的字符能直接显示在屏幕上？如果用一个特殊字符(如，#)来结束输入，就无法在文本中使用这个字符，是否有更好的方法结束输入？要回答这些问题，首先要了解C程序如何处理键盘输入，尤其是缓冲和标准输入文件的概念。  
#### 缓冲区  
如果在老式系统运行程序echo.c，你输入文本时可能显示如下：  

>HHeelllloo,,tthheerree..II wwoouulldd[enter]
>lliikkee aa#

以上行为是个例外。像这样回显用户输入的字符后立即重复打印该字符是属于无缓冲(或直接)输入，即正在等待的程序可立即使用输入的字符。对于该例，大部分系统在用户按下Enter键之前不会重复打印刚输入的字符，这种输入形式属于缓冲输入。用户输入的字符被收集并存储在一个被称为缓冲区(buffer)的临时存储区，按下Enter键后，程序才可使用用户输入的字符。两种输入的对比如下：
![缓冲输入和无缓冲输入.png](../../images/C-Learning/缓冲输入和无缓冲输入.png)  
为什么要有缓冲区？  

* 把若干字符作为一个块进行传输比逐个发送这些字符节约时间。  
* 如果用户打错字符，可以直接通过键盘修正错误。  

虽然缓冲输入好处很多，但是某些交互式程序也需要无缓冲输入。例如，在游戏中，你希望按下一个键就执行相应的指令。因此，缓冲输入和无缓冲输入都有用武之地。  
缓冲分为两类：完全缓冲I/O和行缓冲I/O。完全缓冲输入指的是当缓冲区被填满时才刷新缓冲区(内容被发送至目的地)，通常出现在文件输入中。缓冲区的大小取决于系统，常见的大小是512字节和4096字节。行缓冲I/O指的是在出现换行符时刷新缓冲区。键盘输入通常是行缓冲输入，所以在按下Enter键后才刷新缓冲区。  
那么，使用缓冲输入还是无缓冲输入？ANSI C和后续的C标准都规定输入时缓冲的，不过最初K&R把这个决定权交给了编译器的编写者。  
ANSI C决定把缓冲输入作为标准的原因是：一些计算机不允许无缓冲输入。如果你的计算机允许无缓冲输入，那么你所用的C编译器很可能会提供一个无缓冲输入的选项。例如，许多IBM PC兼容机的编译器都为支持无缓冲输入提供一系列特殊的函数，其原型都在conio.h头文件中。这些函数包括用于回显无缓冲输入的getche()函数和用于无回显无缓冲输入的getch()函数。UNIX系统使用另一种不同的方式控制缓冲。在UNIX系统中，可以使用ioctl()函数指定待输入的类型，然后用getchar()执行相应的操作。在ANSI C中，用setbuf()和setvbuf()函数控制缓冲，但是受限于一些系统的内部设置，这些函数可能不起作用。总之，ANSI没有提供调用无缓冲输入的标准方式，这意味着是否能进行无缓冲输入取决于计算机系统。  

#### 结束键盘输入  
在echo.c程序中，只要输入的字符中不含#，那么程序在读到#时才会结束。但是，#也是一个普通的字符，有时不可避免要用到。应该用一个在文本中用不到的字符来标记输入完成，这样的字符不会无意间出现在输入中，在你不希望结束程序的时候终止程序。C的确提供了这样的字符，不过在此之前，先来了解一下C处理文件的方式。  

1. 文件、流和键盘输入  
文件(file)是存储器中存储信息的区域。通常，文件都保存在某种永久存储器中(如，硬盘、U盘或DVD等)。毫无疑问，文件对于计算机系统相当重要。例如，你编写的C程序就保存在文件中，用来编译C程序的程序也保存在文件中。后者说明，某些程序需要访问指定的文件。当编译存储在名为echo.c文件中的程序时，编译器打开echo.c文件并读取其中的内容。当编译器处理完后，会关闭该文件。其他程序，例如文字处理器，不仅要打开、读取和关闭文件，还要把数据写入文件。  
C是一门强大、灵活的语言，有许多用于打开、读取、写入和关闭文件的库函数。从较低层面上，C可以使用主机操作系统的基本文件工具直接处理文件，这些直接调用操作系统的函数被称为底层I/O(low-level I/O)。由于计算机系统各不相同，所以不可能为普通的底层I/O函数创建标准库，ANSI C也不打算这样做。然而从较高层面上，C还可以通过标准I/O包(standard I/O package)来处理文件。这涉及创建用于处理文件的标准模型和一套标准I/O函数。在这一层面上，具体的C实现负责处理不同系统的差异，以便用户使用统一的界面。  
上面讨论的差异指的是什么？例如，不同的系统储存文件的方式不同。有些系统把文件的内容存储在一处，而文件相关的信息存储在另一处；有些系统在文件中创建一份文件描述。在处理文件方面，有些系统使用单个换行符标记行末尾，而其他系统可能使用回车符和换行符的组合来表示行末尾。有些系统用最小字节来衡量文件的大小，有些系统则以字节块的大小来衡量。  
如果使用标准I/O包，就不用考虑这些差异。因此，可以用if(ch == '\n')检查换行符。即使系统实际用的是回车符和换行符的组合来标记行末尾，I/O函数会在两种表示法之间相互转换。  
从概念上看，C程序处理的是流而不是直接处理文件。流(steam)是一个实际输入或输出映射的理想化数据流。这意味着不同属性和不同种类的输入，由属性更统一的流来表示。于是，打开文件的过程就是把流与文件相关联，而且读写都通过流来完成。  
本章着重理解C把输入和输出设备视为存储设备上的普通文件，尤其是把键盘和显示设备视为每个C程序自动打开的文件。stdin流表示键盘输入，stdout流表示屏幕输出。getchar()、putchar()、printf()和scanf()函数不堵车标准I/O包的成员，处理这两个流。
2. 文件结尾  
计算机操作系统要以某种方式判断文件的开始和结束。检测文件结尾的一种方法是，在文件末尾放一个特殊的字符标记文件结尾。CP/M、IBM-DOS和MS-DOS的文本文件曾经使用过这种方法。如今，这些操作系统可以使用内嵌的Ctrl+Z字符来标记文件结尾。这曾经是操作系统使用的唯一标记，不过现在有一些其他的选择，例如记录文件的大小。所有现代的文本文件不一定有嵌入的Ctrl+Z,但是如果有，该操作系统会将其视为一个文件结尾标记。  
操作系统使用的另一种方法是存储文件大小的信息。如果文件有3000字节，程序在读到3000字节时便达到文件的末尾。MS-DOS及其相关系统使用这种方法处理二进制文件，因为用这种方法可以在文件中存储所有的字符包括Ctrl+Z。新版的DOS也使用这种方法处理文本文件。UNIX使用这种方法处理所有的文件。  
无论操作系统实际使用何种方法检测文件结尾，在C语言中，用getchar()读取文件检测到文件结尾时将返回一个特殊的值，即EOF(end of file的缩写)。scanf()函数检测到文件结尾时也返回EOF。通常，EOF定义在stdio.h文件中。  
如何在程序中使用EOF？把getchar()的返回值和EOF作比较。如果两值不同，就说明没有达文件结尾。也就是说，可以使用下面这样的表达式:  
```C 
while((ch = getchar())!=EOF)
```
如果正在读取的是键盘输入不是文件会怎样？绝大部分系统都有办法通过键盘模拟文件结尾条件。了解这些以后，读者可以重写程序清单8.1的程序。  
[echo_eof.c](../../c-example/echo_eof.c)  
既然echo_eof.c程序能把用户输入的内容拷贝到屏幕上，那么考虑一下该程序还可以做什么。假设以某种方式把一个文件传送给它，然后它把文件中的内容打印在屏幕上，当到达文件结尾发现EOF信号时停止。或者，假设以某种方式把程序的输出定向到一个文件，然后通过键盘输入数据，用echo_eof.c来储存文件中输入的内容。假设同时使用这两种方法：把输入从一个文件定向到echo_eof.c中，并把输出发送至另一个文件，然后便可以使用echo_eof.c来拷贝文件。关键是要控制输入流和输出流，这是我们下一个要讨论的主题。  

#### 重定向和文件  
输入和输出涉及函数、数据和设备。例如，考虑echo_eof.c，该程序使用输入函数getchar()。输入设备是键盘，输入数据流由字符组成。假设你希望输入函数和数据类型不变，仅改变程序查找数据的位置。那么，程序如何知道去哪里查找输入。  
在默认情况下，C程序使用标准I/O包查找标准输入作为输入源。这就是前面介绍过的stdin流，它是把数据读入计算机的常用方式。它可以是一个过时的设备，如磁带、穿孔卡或电传打印机，或者是键盘，甚至是一些先进技术，如语音输入。然而，现代计算机非常灵活，可以让它到别处查找输入。尤其是，可以让一个程序从文件中查找输入，而不是从键盘。  
程序可以通过两种方式使用文件。第1种方法是，显式使用特定的函数打开文件、关闭文件、读取文件、写入文件，诸如此类。在后续章节再详细介绍这种方法。第2种方法是，设计能与键盘和屏幕互动的程序，通过不同的渠道重定向输入至文件和从文件输出。换言之，把stdin流重新赋给文件。继续使用getchar()函数从输入流中获取数据，但它不关心从流的什么位置获取数据。虽然这种重定向的方法在某些方面有些限制，但是用起来比较简单，而且能让读者熟悉普通的文件处理技术。  
重定向的一个主要问题与操作系统有关，与C无关。尽管如此，许多C环境中(包括UNIX、Linux和Windows命令提示模式)都有重定向特性，而且一些C实现还在某些缺乏重定向特性的系统中模拟它。在UNIX上运行苹果OS X，可以用UNIX命令行模式启动Terminal应用程序。接下来介绍UNIX、Linux和Windows的重定向。  
UNIX(运行命令行模式时)、Linux(ditto)和Window命令行提示都能重定向输入、输出。重定向输入让程序使用文件而不是键盘输入，重定向输出让程序输出至文件而不是屏幕。  

1. 重定向输入  
    假设已经编译了echo_eof.c程序，并把可执行版本放入一个名为echo_eof的文件中。运行该程序，输入可执行文件名：echo_eof  
    该程序的运行情况和前面描述的一样，获取用户从键盘输入的输入。现在，假设你要用该程序处理名为words的文本文件。文本文件(text file)时内含文本的文件，其中储存的数据是我们可识别的字符。文件的内容可以是一篇散文或者C程序。内涵机器语言指令的文件(如存储可执行程序的文件)不是文本文件。由于该程序的操作对象是字符，所以要使用文本文件。  
    只需用下面的命令代替上面的命令即可：  

    ``` shell
    echo_eof<words  
    ```

    \<符号是UNIX和DOS/Windows的重定向运算符。该运算符使words文件与stdin流相关联，把文件中的内容导入echo_eof程序。echo_eof程序本身并不知道输入的内容是来自文件还是键盘就，它只知道这是需要导入的字符流，所以它读取这些内容并把字符逐个打印在屏幕上，直至读到文件结尾。因为C把文件和I/O设备放在一个层面，所以文件就是现在的I/O设备放在一个层面，所以文件就是现在的I/O设备。
2. 重定向输出  
    现在假设要用echo_eof把键盘输入的内容发送到名为mywords的文件中。然后，输入以下命令并开始输入：  

    ``` shell
    echo_eof > mywords  
    ```

    />符号是第2个重定向运算符。它创建了一个名为mywords的新文件，然后把echo_eof的输出重定向至该文件中。重定向把stdout从显示设备(显示器)赋给mywords文件。如果已经有一个名为mywords的文件，通常会擦除该文件的内容，然后替换新的内容。所有出现在屏幕的字母都是你刚才输入的，其副本存储在文件中。在下一行的开始处按下Ctrl+D或Ctrl+Z即可结束该程序。
3. 组合重定向  
    现在，假设你希望制作一份mywords文件的副本，并命名为savewords。只需输入以下命令即可：  

    ``` shell
    echo_eof < mywords > savewords  
    ```

    下面的命令也起作用，因为命令与重定向运算符的顺序无关：  

    ``` shell
    echo_eof > savewords < mywords  
    ```

    在UNIX、Linux或Windows/DOS系统中使用两个重定向运算符(< 和 >)时，要遵循以下原则  
    * 重定向运算符连接一个可执行程序和一个数据文件  
    * 使用重定向运算符不能读取多个文件的输入，也不能把输出定向至多个文件  
    * 文件名和运算符之间的空格不是必须的  

    UNIX、Linux或Windows/DOS还有>>运算符，该运算符可以把数据添加到现有文件的末尾，而|运算符能把一个文件的输出连接到另一个文件的输入。  

#### 创建更友好的用户界面  

1. 使用缓冲输入  
    缓冲输入用起来比较方便，因为在把输入发送给程序之前，用户可以编辑输入。但是，在使用输入的字符时，它也会给程序员带来麻烦。前面实例中看到的问题是，缓冲输入要求用户按下Enter键发送输入。这一动作也传送了换行符，程序必须妥善处理这个麻烦的换行符。我们以一个猜谜程序为例。用户选择一个数字，程序猜用户选中的数字是多少。该程序使用的方法单调乏味，先不要在意算法，我们关注的重点在输入和输出。如下：  
    [guess.c](../../c-example/guess.c)  
    注意，每次输入n时，程序打印了两条消息。这是由于程序读取n作为用户否定了数字1，然后还读取了一个换行符作为用户否定了数字2。  
    一种解决方案是，使用while循环丢弃输入行最后剩余的内容，包括换行符。这种方法的优点是，能把no和no way这样的响应视为简单的n。  
    
    ``` C 
    while(getchar()!='y')
    {
        printf("Well, then, is is %d?\n", ++guess);
        while(getchar() != '\n')
            continue;
    }
    ```

    这的确是解决了换行符的问题。但是，该程序还是会把f视为n。我们用if语句筛选其他响应。

    ``` C
    char response;
    while((response = getchar()) != 'y')
    {
        if(response == 'n')
            printf("Well, then, is it %d?\n", ++guess);
        else
            printf("Sorry, I understand only y or n.\n");
        while(getchar() != '\n')
            continue;
    }
    ```

2. 混合数值和字符输入  
    假设程序要求用getchar()处理字符输入，用scanf()处理数值输入，这两个函数都能很好地完成任务，但是不能把它们混用。因为getchar()读取每个字符，包括空格、制表符和换行符；而scanf()在读取数字时则会跳过空格、制表符和换行符。  
    [showchar1.c](../../c-example/showchar1.c)  
    while循环实现了丢弃scanf()输入后面所有字符(包括换行符)的功能，为循环的下一轮读取做好了准备。  

#### 输入验证  
    在实际应用中，用户不一定会按照程序的指令行事。用户的输入和程序期望的输入不匹配时常发生，这会导致程序运行失败。作为程序员，除了完成编程的本职工作，还要事先预料一些可能的输入错误，这样才能编写出能检测并处理这些问题的程序。  
    假如，你编写了一个处理非负数整数的循环，但是用户很可能输入一个负数。你可以使用关系表达式来排除这种情况：  

    ``` C 
    long n;
    scanf("%ld",&n);
    while(n >= 0)
    {
        //处理n  
        scanf("%ld",&n);//获取下一个值
    }
    ```

    另一类潜在的陷阱是，用户可能输入错误类型的值，如字符q。排除这种情况的一种方法是，检查scanf()的返回值。scanf()返回成功读取项的个数。因此，改进如下：  

    ``` C 
    long n;
    while(scanf("%ld",&n) == 1 && n >= 0)
    {
        //处理n
    }
    ```

    while循环条件可以描述为“当输入是一个整数且该整数为正时”。  
    对于最后的例子，当用户输入错误类型的值是，程序结束。然而，也可以让程序友好些，提示用户再次输入正确类型的值。在这种情况下，要处理有问题的输入。如果scanf()没有成功读取，就会将其留在输入队列中。这里要明确，输入实际上是字符流。可以使用getchar()函数逐字符地读取输入，甚至可以把这些想法结合在一个函数中，如下：  

    ``` C
    long get_long(void)
    {
        long input;
        char ch;
        while(scanf("%ld",&input) != 1)
        {
            while((ch = getchar()) != '\n')
                putchar(ch);
            printf(" is not an integer.\nPlease enter an");            printf("integer value,such as 25,-178,or 3:");
        }
        return input;
    }
    ```

    该函数要把一个int类型的值读取变量input中。如果读取失败，函数则进入外层循环体。然后内层循环逐字符地读取错误的输入。注意，该函数丢弃该输入行的所有剩余内容。还有一个方法是，只丢弃下一个字符或单词，然后该函数提示用户再次输入。外层循环重复运行，直到用户成功输入整数，此时scanf()的返回值为1。  
   
    在用户输入整数后，程序可以检查该值是否有效。考虑一个例子，要求用户输入一个上限和一个下限来定义值的范围。在该例中，你可能希望程序检查第1个值是否大于第2个值，除此之外还要检查这些值是否在允许的范围内。如下：  

    ``` C
    bool bad_limits(long begin, long end, long low, long high)
    {
        bool not_good = false;
        if(begin > end)
        {
            printf("%ld isn't smaller than %ld.\n",begin, end);
            not_good = true;
        }
        if(begin < low || end < low)
        {
            printf("Values must be %ld or greater.\n",low);
            not_good = true;
        }
        if(begin > high || end > high)
        {
            printf("Values must be %ld or less.\n",high);
            not_good = true;
        }
        return not_good;
    }
    ```

    下列函数使用了上述两个函数为一个进行算术运算的函数提供整数，该函数计算特定范围内所有整数的平方和。程序限制了范围的上限是10000000，下限是-10000000。  
    [checking.c](../../c-example/checking.c)  
    
#### 菜单浏览  

